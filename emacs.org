* Overview
This is my personal setup for Emacs. Most everything should work right out of
the box, but one may need to do some fanagling to get it to work the first time.
This whole setup essentially hinges on req-package, use-package's slightly more
robust sibling. \\
One thing to note is that I use the Colemak keyboard layout, which means some of
my keybindings may seem a little weird. I've thought of this and created a flag
called =flag-colemak= in init.el. If you want to use more QWERTY bindings, set
that to 0 instead of 1. These other bindings will be listed in [ ] next to the
defaults. \\
I also use the super key (s- ) in a few of my bindings. If you want to use them
as-is, you need to look into getting the key to work properly on your OS.
* General Settings
** Clean Init
I don't like the splash-screen, and I don't need the tool bar, menu bar, or
scroll bar, so get rid of them.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC
** Tab Configuration
I use 2 space tabs, and (for my preferences) I use spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2
                indent-tabs-mode nil)

#+END_SRC
** Input Method
It's always a pain to input fancy unicode characters. I have char-menu to
alleviate some of this, but for less used characters, I use this to type
them with LaTeX style \ codes.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method 'TeX)
#+END_SRC
** Smooth Scrolling
I really don't like how Emacs scrolls by default, so this code implements smooth
scrolling.

#+BEGIN_SRC emacs-lisp
  (setq redisplay-dont-pause t ;;Smooth scrolling
        scroll-margin 3
        scroll-step 1
        scroll-conservatively 10000
        scroll-preserve-screen-position 1)
#+END_SRC
** Hide Make Buffers
I don't really like having a new window pop up to tell me what happened during a
make. This makes it so that the minibuffer tells you whether the compilation
succeeded or failed.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'display-buffer-alist
               '("*compilation*" . (display-buffer-no-window)))
#+END_SRC
** Make Magit Buffer Big
When calling Magit status, usually the buffer only takes up half the screen,
which isn't really pretty. This makes it so that doesn't happen.
This is taken from [[http://www.lunaryorn.com/2016/04/28/fullscreen-magit-status.html][here]].

#+BEGIN_SRC emacs-lisp
  (defun my-display-buffer-fullframe (buffer alist)
    "Display BUFFER in fullscreen.
  ALIST is a 'display-buffer' ALIST."
    (let ((window (or (display-buffer-use-some-window buffer alist)
                      (display-buffer-pop-up-window buffer alist))))
      (when window
        (delete-other-windows window)
        window)))

  (add-to-list 'display-buffer-alist
               `(,(rx "*magit: ")
                 (my-display-buffer-fullframe)
                 (reusable-frames . nil)))
#+END_SRC
** Set Default Browser To EWW
I used to have this set to conkeror, but for some reason it just doesn’t
actually open links. Anyways, EWW just got serious improvements, so I’ll
just use that instead.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'eww-browse-url)
#+END_SRC
** Set Alternate Browser to Conkeror
I really wish I could get this to work for Conkeror, but running that browser
is like balancing on a knife edge in my current setup. Oh well. This is opened
up in eww by pressing &, which I may want to remap at some point.

#+BEGIN_SRC emacs-lisp
  (setq shr-external-browser 'open-url-conkeror)
#+END_SRC
** Overwrite Selected Text
Emacs usually deselects a region once you start typing, but I like it to delete
the selected text in that case.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC
** File Encoding
UTF-8 is amazing, so use that by default.

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC
** Lego Theme
My own creation, and definitely still a work in progress, but I can change 
whatever I want to whenever I need to, so that's nice.

#+BEGIN_SRC emacs-lisp
  (load-theme 'lego t)
#+END_SRC
** Font
This is just the font I’m using.

#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist (cons '(font . "DejaVu Sans Mono-14")
                                  default-frame-alist))
#+END_SRC
** Stop That Infernal Beeping
I hate Emacs beeping whenever I do anything, and this fixes it…in a really
roundabout way. Basically I’m overriding the function that says to “beep”
with the no-op thunk.

#+BEGIN_SRC emacs-lisp
  (defun thunk ())
  (setq ring-bell-function 'thunk)
#+END_SRC
* Package
** Control
*** [[https://github.com/abo-abo/avy][avy]]
A lovely package that allows you to quickly jump to wherever you want to go
practically instantly.
- keybinds:
  + M-s - use avy with one word
  + M-l - use avy to go to a line
#+BEGIN_SRC emacs-lisp
  (req-package avy
    :bind
    (("M-s" . avy-goto-word-1)
     ("M-S-s" . avy-goto-char-2)
     ("M-l" . avy-goto-line)))
#+END_SRC
*** [[https://github.com/joodland/bm][bm]]
An extremely simple yet really helpful package that allows you to mark multiple
different positions in a file and cycle through them with ease. Really useful
when you need to go looking for something but want to save your spot, or if you 
keep bouncing between a few spots in a file.
#+BEGIN_SRC emacs-lisp
  (req-package bm ;;make bookmarks and cycle through them
    :config
    (global-set-key (kbd "s-d") 'bm-toggle)
    (if (= flag-colemak 1)
        (progn
          (global-set-key (kbd "C-M-n") 'bm-next)
          (global-set-key (kbd "C-M-p") 'bm-previous))
      (progn
        (global-set-key (kbd "s-j") 'bm-next)
        (global-set-key (kbd "s-k") 'bm-previous))))
#+END_SRC    
*** [[https://github.com/abo-abo/swiper][counsel]]
#+BEGIN_SRC emacs-lisp
  (req-package counsel
    :bind
    (("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))
  (global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC
*** [[https://github.com/magnars/expand-region.el][expand-region]]
Gives the ability to quickly create and expand a region to fill some kind of
boundary, like parentheses or quotes. This gives Emacs something like the
functionality of Vim with its "change-in" commands.

#+BEGIN_SRC emacs-lisp
  (req-package expand-region
    :config
    (global-set-key (kbd "M-i") 'er/expand-region))
#+END_SRC
*** [[https://github.com/victorhge/iedit][iedit]]
Allows you to edit all instances of the word under the cursor at the same time,
which can be quite the timesaver when refactoring things. Alongside narrowing
buffers, this can be super powerful. Currently bound to =C-;=.

#+BEGIN_SRC emacs-lisp
  (req-package iedit)
#+END_SRC
*** [[https://github.com/abo-abo/swiper][ivy]]
This is a generic completion package that is used as a backend for swiper.
It pulls up a larger minibuffer that shows all the possible completions.

#+BEGIN_SRC emacs-lisp
  (req-package ivy
    :diminish ivy-mode
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))) ;; Use fuzzy matching
    (define-key ivy-minibuffer-map (kbd "C-p") 'ivy-previous-line)
    (define-key ivy-minibuffer-map (kbd "C-n") 'ivy-next-line)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (ivy-mode 1))
#+END_SRC
*** [[https://github.com/abo-abo/hydra][hydra]]
This lovely package allows for improved use of chaining similar commands.
I'll be trying to use it to wean myself off of some of the features
of evil-mode, but I'm sure I'll keep both installed for a while.

#+BEGIN_SRC emacs-lisp
  (req-package hydra
    :config
    (defhydra hydra-motion (:body-pre (next-line))
      "motion"
      ("h" backward-char "←")
      ("n" next-line "↓")
      ("e" previous-line "↑")
      ("i" forward-char "→")
      ("M-h" sk/smarter-beginning-of-line "BoL")
      ("M-i" move-end-of-line "EoL")
      ("N" scroll-up-command "Pg ↓")
      ("E" scroll-down-command "Pg ↑")
      ("H" backward-word "←←")
      ("I" forward-word "→→")
      ("g" nil "×"))
    (global-set-key (kbd "C-n") #'hydra-motion/next-line))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/KeyChord][key-chord]]
Allows the ability to define different key chords, key combinations
that trigger an action when pressed in quick succession.

#+BEGIN_SRC emacs-lisp
  (req-package key-chord
    :config
    (setq key-chord-one-key-delay 0.2)
    (setq key-chord-two-key-delay 0.2)
    (key-chord-define c-mode-map ".." "->")
    (key-chord-define c++-mode-map ".." "->")
    (key-chord-define global-map "-." "→")
    (key-chord-define-global ",-" "←")
    (key-chord-define-global "--" "_")
    (key-chord-define-global "vf" 'find-file)
    (key-chord-define-global "vu" 'undo)
    (key-chord-define-global "vs" 'save-buffer)
    (key-chord-define-global "vl" 'ispell-region)
    (key-chord-define-global "VL" 'endless/ispell-word-then-abbrev)
    (key-chord-mode 1))
#+END_SRC
*** [[https://github.com/noctuid/link-hint.el][link-hint]]
I really don’t like manually moving the cursor around just to select a link, so
I just use this to jump straight to links when in things like EWW.

#+BEGIN_SRC emacs-lisp
  (req-package link-hint
    :bind ("M-L" . link-hint-open-link)
    :config
    (define-key eww-mode-map (kbd "f") 'link-hint-open-link))
#+END_SRC
*** [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]]
A do-it-yourself modal control system which allows for the benefits of things
like Evil while still preserving the base Emacs. I'll be building this up over
time, and I really want to find a way to have multiple different types of modes
with different commands each.

#+BEGIN_SRC emacs-lisp
  (req-package ryo-modal
    :bind ("M-m" . ryo-modal-mode)
    :config
    (ryo-modal-keys
     ("m" ryo-modal-mode)
     ("0" "M-0")
     ("1" "M-1")
     ("2" "M-2")
     ("3" "M-3")
     ("4" "M-4")
     ("5" "M-5")
     ("6" "M-6")
     ("7" "M-7")
     ("8" "M-8")
     ("9" "M-9")
     ("h" backward-char)
     ("H" backward-word)
     ("n" next-line)
     ("e" previous-line)
     ("i" forward-char)
     ("I" forward-word)
     ("l" avy-goto-line)
     ("v" scroll-up-command)
     ("V" scroll-down-command)
     ("g" beginning-of-buffer)
     ("G" end-of-buffer)
     ("d" delete-char)
     ("D" delete-word)
     ("k" kill-line)
     ("K" kill-whole-line)
     ("y" yank)
     ("Y" counsel-yank-pop)
     ("z" zzz-up-to-char)
     ("Z" zzz-to-char)
     ("s" save-buffer)
     ("S" swiper)))
#+END_SRC
*** [[http://elpa.gnu.org/packages/smart-yank.html][smart-yank]]
Makes yanking a little smarter. For one thing, when doing a yank-pop, it moves
the cut that you've popped to the top of the ring to make it easier the next
time, while it also resets the stack position upon any command rather than only
on kills.

#+BEGIN_SRC emacs-lisp
  (req-package smart-yank
    :config
    (smart-yank-mode 1))
#+END_SRC
*** [[https://github.com/abo-abo/swiper][swiper]]
This basically extends ivy-mode to provide a comprehensive overview of whatever
you’re searching for.

#+BEGIN_SRC emacs-lisp
  (req-package swiper
    :requires ivy
    :config
    (global-set-key (kbd "C-s") 'swiper))
#+END_SRC
*** [[https://github.com/mrkkrp/zzz-to-char][zzz-to-char]]
Visually kill a part of a line, forward or backward, to a given character.
This in some ways shoots Vim's kill-to command out of the water, simply
because of how easy it is to go to a specific instance of a character with
an avy backend.

#+BEGIN_SRC emacs-lisp
  (req-package zzz-to-char
    :bind
    (("M-z" . zzz-up-to-char)
     ("M-S-z" . zzz-to-char)))
#+END_SRC
** Programming
*** [[https://www.emacswiki.org/emacs/CcMode][cc-mode]]
Built into Emacs. I'm just putting this here to establish a few start up hooks.
I have individual setups for each C-type mode, just so that they actually work.

#+BEGIN_SRC emacs-lisp
  (setq-default c-basic-offset 2)
  (setq-default c++-basic-offset 2)

  (defun add-ac-sources ()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (add-hook 'cc-mode-common-hook 'add-ac-sources)
  (add-hook 'c-mode-common-hook 'add-ac-sources)
  (add-hook 'c++-mode-common-hook 'add-ac-sources)

  (add-hook 'cc-mode-hook 'semantic-mode)
  (add-hook 'c-mode-hook 'semantic-mode)
  (add-hook 'c++-mode-hook 'semantic-mode)

#+END_SRC
*** [[https://github.com/jscheid/dtrt-indent][dtrt-indent]]
This is an especially useful package when editing code that somebody else wrote,
as it automatically detects what the indentation size is and sets yours to
match.

#+BEGIN_SRC emacs-lisp
  (req-package dtrt-indent)
#+END_SRC
*** [[https://github.com/lewang/fic-mode][fic-mode]]
Another tiny yet remarkably helpful package that just highlights keywords like
TODO or FIXME in comments. It is currently turned on in any prog-mode. Someday I
should just write something like this myself, both for experience and so that
this doesn't keep slowing down my boot up time.

#+BEGIN_SRC emacs-lisp
  (req-package fic-mode
    :diminish fic-mode
    :config
    (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC
*** [[https://github.com/flycheck/flycheck][flycheck]]
A magic little syntax checker for various languages like C. It sets a compiler
flag for gnu11, since my computer doesn'tcompile for loops and the like by
default for some reason. Triggered in any prog-mode.

#+BEGIN_SRC emacs-lisp
  (defun setup-flycheck-rtags ()
    (interactive)
    "Stolen from https://vxlabs.com/tag/rtags/."
    (flycheck-select-checker 'rtags)
    (setq-local flycheck-highlighting-mode nil)
    (setq-local flycheck-check-syntax-automatically nil))

  (req-package flycheck
    :require rtags
    :config
    (flycheck-set-checker-executable 'c/c++-gcc "/usr/bin/gcc")
    (setq flycheck-gcc-args "-std=gnu11")

    ;; (when (require 'rtags nil :noerror)
    ;;   (require 'company)
    ;;   (define-key c-mode-base-map (kbd "s-n")
    ;;     (function rtags-find-symbol-at-point))
    ;;   (define-key c-mode-base-map (kbd "s-k")
    ;;     (function rtags-find-references-at-point))
    ;;   (rtags-enable-standard-keybindings)
    ;;   (setq rtags-autostart-diagnostics t)
    ;;   (rtags-diagnostics)
    ;;   (setq rtags-completions-enabled t)
    ;;   (push 'company-rtags company-backends)
    ;;   (global-company-mode t)
    ;;   (define-key c-mode-base-map (kbd "<C-tab>")
    ;;     (function company-complete))
    ;;   (require 'flycheck-rtags)
    ;;   (add-hook 'c-mode-common-hook #'setup-flycheck-rtags))

    (add-hook 'prog-mode-hook 'flycheck-mode))
#+END_SRC
*** gdb
I prefer the many windows mode of gdb.

#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t)
#+END_SRC
*** [[https://github.com/leoliu/ggtags][ggtags]]
C/C++ program tagging. This allows one to easily jump around a program to
definitions and usages of variables and functions.
- keybinds:
  + M-g M-g - go to either the definition or usage of the symbol at point
  + M-g r - return to the last point jumped from
    
#+BEGIN_SRC emacs-lisp
(req-package ggtags
  :diminish ggtags-mode
  :config
  (add-hook 'c-mode-hook #'ggtags-mode)
  (add-hook 'c++-mode-hook #'ggtags-mode)
  (add-hook 'cc-mode-hook #'ggtags-mode)
  (add-hook 'java-mode-hook #'ggtags-mode)
  (add-hook 'asm-mode-hook #'ggtags-mode)
  (define-key ggtags-mode-map (kbd "M-g M-g") #'ggtags-find-tag-dwim)
  (define-key ggtags-mode-map (kbd "M-g r") #'ggtags-prev-mark))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/HideShow][hs]]
A very effective code folding package that is started in any prog-mode.
    
#+BEGIN_SRC emacs-lisp
  (add-hook 'hs-minor-mode-hook '(lambda () (diminish 'hs-minor-mode)))
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (global-set-key (kbd "C-c C-f") 'hs-toggle-hiding)
#+END_SRC
*** lisp-mode
Built into Emacs (or more specifically, builds Emacs) by default. Right now I'm
just specifying .stumpwmrc should be in lisp mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '(".stumpwmrc" . lisp-mode))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/MakefileMode][makefile-mode]]
Built into Emacs by default. I'm just adding Doxyfiles to make them more
readable.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("Doxyfile" . makefile-mode))
#+END_SRC
*** [[https://github.com/bbatsov/projectile][projectile]]
Helps finding files in a given project. I'm not entirely sure if or how this is
working, so I'll fiddle around with it.

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :diminish projectile-mode
    :requires ivy
    :init
    (projectile-global-mode)
    (setq projectile-enable-caching t)
    (setq projectile-completion-system 'ivy))
#+END_SRC
*** [[https://github.com/syohex/emacs-quickrun][quickrun]]
Ever wanted to just compile and run a program with one short keystroke? This
allows you to do just that.

#+BEGIN_SRC emacs-lisp
  (defun load-quickrun ()
    (require 'quickrun)
    (quickrun-add-command "c/gcc"
                          '((:command . "gcc")
                            (:exec . ("%c %o -std=gnu11 -o %e %s" "%e")))
                          :override t))

  (add-hook 'prog-mode-hook 'load-quickrun)
#+END_SRC
*** scheme-mode
A lot of these settings are from the default config for my CSSE304 class.
I am using petite chez as my interpereter, as it is required for the class.

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq scheme-program-name "petite")

  (put 'eval-when 'scheme-indent-function 1)
  (put 'set! 'scheme-indent-function 1)
  (put 'when 'scheme-indent-function 1)
  (put 'unless 'scheme-indent-function 1)
  (put 'record-case 'scheme-indent-function 1)
  (put 'c-record-case 'scheme-indent-function 1)
  (put 'variant-case 'scheme-indent-function 1)
  (put 'parameterize 'scheme-indent-function 1)
  (put 'call-with-values 'scheme-indent-function 1)
  (put 'extend-syntax 'scheme-indent-function 1)
  (put 'with 'scheme-indent-function 1)
  (put 'let 'scheme-indent-function 1)
  (put 'let-syntax 'scheme-indent-function 1)
  (put 'letrec-syntax 'scheme-indent-function 1)
  (put 'with-syntax 'scheme-indent-function 1)
  (put 'syntax-case 'scheme-indent-function 2)
  (put 'syntax 'scheme-indent-function 1)
  (put 'syntax-rules 'scheme-indent-function 1)
  (put 'foreign-procedure 'scheme-indent-function 1)
  (put 'set-top-level-value! 'scheme-indent-function 1)
  (put 'make-parameter 'scheme-indent-function 1)
  (put 'decompose 'scheme-indent-function 2)
  (put 'mvlet 'scheme-indent-function 1)
  (put 'mvlet* 'scheme-indent-function 1)
  (put 'state-case 'scheme-indent-function 1)
  (put 'foreach 'scheme-indent-function 1)
  (put 'vector-foreach 'scheme-indent-function 1)
  (put 'assert 'scheme-indent-function 1)
  (put 'fold-list 'scheme-indent-function 2)
  (put 'fold-vector 'scheme-indent-function 2)
  (put 'fold-count 'scheme-indent-function 2)
  (put 'on-error 'scheme-indent-function 1)
#+END_SRC
*** [[http://www.gnu.org/software/emacs/manual/html_node/semantic/index.html][semantic]]
Built into Emacs by default. Sets the refresh time and some keybinds.

#+BEGIN_SRC emacs-lisp
  (req-package semantic
    :init
    (global-semanticdb-minor-mode 1)
    (global-semantic-idle-scheduler-mode 1)
    (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
    (global-set-key (kbd "M-g TAB") 'semantic-complete-analyze-inline)
    (global-set-key (kbd "M-g g") 'semantic-complete-jump-local))
#+END_SRC
*** TODO [[https://github.com/slime/slime][slime]]
I’m going to try this just to see if it helps my lisp coding any.

#+BEGIN_SRC emacs-lisp
  (setq inferior-lisp-program "/usr/bin/sbcl")
  (req-package slime
    :init
    (setq slime-contribs '(slime-fancy))
    (slime-setup))
#+END_SRC
*** stumpwm-mode
Since I use StumpWM, this should come in handy.

#+BEGIN_SRC emacs-lisp
  (req-package stumpwm-mode
    :config
    (add-to-list 'auto-mode-alist '(".stumpwmrc" . stumpwm-mode)))
#+END_SRC
** Usability
*** [[https://github.com/jgkamat/alda-mode][alda-mode]]
Ties into the musical programming language alda. It's just kind of fun to mess
around in.

#+BEGIN_SRC emacs-lisp
  (req-package alda-mode
    :config
    (setq set-alda-binary-location "/usr/local/bin/alda"))
#+END_SRC
*** [[https://github.com/cdominik/cdlatex][cdlatex]]
Provides quick shortcuts for lots of long latex symbols. For example, `a turns
into =\alpha=.

#+BEGIN_SRC emacs-lisp
(req-package cdlatex
  :diminish cdlatex-mode
  :require auctex)
#+END_SRC
*** [[https://github.com/mrkkrp/char-menu][char-menu]]
Allows you to build your own tree of special characters that can be accessed via
an avy-menu...menu.
    
#+BEGIN_SRC emacs-lisp
  (req-package char-menu
    :init
    (setq char-menu '("’" "‘’" "“”" "…" "⌊⌋" "⋀" "⋁" "√" ("script" "ℛ" "ℒ")))
    (global-set-key (kbd "M-o") 'char-menu))
#+END_SRC
*** [[https://github.com/darksmile/cheatsheet/][cheatsheet]]
Just shows a quick list of handwritten keybindings and descriptions that you can
pull up whenever you want. This section makes heavy usage of the
=(substitute-command-keys)= function, which looks to see whatever the command is
currently bound to and uses its string. This means I don't have to rewrite this
whenever I rebind keys.

#+BEGIN_SRC emacs-lisp
  (req-package cheatsheet
    :requires avy semantic hs resize-window flycheck
    :init
    (cheatsheet-add
     :group 'Motion
     :key (substitute-command-keys "\\[avy-goto-char-2]")
     :description "Jump to a 2-character sequence.")
    (cheatsheet-add
     :group 'Motion
     :key (substitute-command-keys "\\[avy-goto-line]")
     :description "Jump to a line.")
    (cheatsheet-add
     :group 'Tags
     :key "M-g M-g"
     :description "Jump to the definition of the symbol under the cursor.")
    (cheatsheet-add
     :group 'Tags
     :key "M-g r"
     :description "Jump back to the previous jump origin.")
    (cheatsheet-add
     :group 'Tags
     :key (substitute-command-keys "\\[semantic-complete-jump-local]")
     :description "Prompt for a function, then jump to the definition.")
    (cheatsheet-add
     :group 'Programming
     :key (substitute-command-keys "\\[hs-toggle-hiding]")
     :description "Toggle code folding.")
    (cheatsheet-add
     :group 'Common
     :key (substitute-command-keys "\\[resize-window]")
     :description "Enter resize-window mode.")
    (cheatsheet-add
     :group 'Programming
     :key (substitute-command-keys "\\[flycheck-next-error]")
     :description "Go to the next error in this program.")
    (cheatsheet-add
     :group 'Common
     :key (substitute-command-keys "\\[flyspell-mode]")
     :description "Toggle flyspell mode in this buffer.")
    (global-set-key (kbd "C-h h") 'cheatsheet-show))
#+END_SRC
*** [[https://github.com/company-mode/company-mode][company]]
Autocomplete that goes with just about everything. This is currently enabled
globally.

#+BEGIN_SRC emacs-lisp
  (req-package company ;;TODO Speed up
    :diminish company-mode
    :config
    (global-company-mode))
#+END_SRC
*** [[https://github.com/Malabarba/conkeror-minor-mode][conkeror-mode]]
This allows you to send lines to conkeror to be evaluated live.

#+BEGIN_SRC emacs-lisp
  (req-package conkeror-minor-mode
    :config
    (add-hook 'js-mode-hook (lambda ()
                              (when (string= ".conkerorrc" (buffer-name))
                                (conkeror-minor-mode 1))))
    (setq conkeror-file-path "~/programs/conkeror/application.ini"))
#+END_SRC
*** [[https://github.com/myrjola/diminish.el][diminish]]
Allows you to stop showing the name of specific minor modes.

#+BEGIN_SRC emacs-lisp
  (req-package diminish
    :config
    (diminish 'abbrev-mode))
#+END_SRC
*** dired
#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t
        dired-recursive-copies 'top
        dired-recursive-deletes 'top
        dired-listing-switches "-alh")
#+END_SRC
*** [[https://github.com/skeeto/elfeed][elfeed]]
An RSS reader that loads from elfeed.org. Basically I use it to check GitHub and
various Emacs sites.
- keybinds:
  + g - (in elfeed mode) refresh the feed
  + r - (in elfeed mode) mark as read
  + u - (in elfeed mode) mark as unread
    
#+BEGIN_SRC emacs-lisp
  (req-package elfeed
    :config
    (global-set-key (kbd "s-l") 'elfeed))
#+END_SRC
*** [[https://github.com/remyhonig/elfeed-org][elfeed-org]]
Allows you to define your RSS feeds in an org file, which makes it so much more
readable.

#+BEGIN_SRC emacs-lisp
  (req-package elfeed-org
    :require elfeed
    :config
    (elfeed-org))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/FlySpell][flyspell]]
Built into Emacs by default. I only take this opportunity to set a quick keybind.

#+BEGIN_SRC emacs-lisp
  (req-package flyspell
    (global-set-key (kbd "C-c l") 'flyspell-mode))
#+END_SRC
*** [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]
When editing a file under version control, this shows little markers indicating
if a line has been added, modified, or deleted.

#+BEGIN_SRC emacs-lisp
  (req-package git-gutter-fringe
    :diminish git-gutter-mode
    :init
    (global-git-gutter-mode 1))
#+END_SRC

*** [[https://github.com/pidu/git-timemachine][git-timemachine]]
Allows you to quickly go through the git history of a file.

p = previous
n = next
w = view hash
W = copy hash
q = quit

#+BEGIN_SRC emacs-lisp
  (req-package git-timemachine)
#+END_SRC
*** [[https://github.com/magit/magit][magit]]
The best way to use git with Emacs. Period.

#+BEGIN_SRC emacs-lisp
  (req-package magit ;;git porcelain
    :init
    (setq magit-restore-window-configuration t)
    (setq magit-completing-read-function 'ivy-completing-read)
    (global-set-key (kbd "s-g") 'magit-status)
    (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))
#+END_SRC
*** [[http://orgmode.org/][org-mode]]
Built into Emacs by default, but I need to configure some of it, especially how the agenda works.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-agenda-include-diary t)
  (setq org-agenda-start-on-weekday nil)
  (setq org-ellipsis "…")
  (setq org-src-fontify-natively t)
  (setq org-clock-idle-time 5)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
  (add-hook 'org-mode-hook 'org-toggle-latex-fragment)
  (add-hook 'org-cdlatex-mode-hook (lambda () (diminish 'org-cdlatex-mode)))
  (add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
  (add-hook 'org-mode-hook (lambda ()
                             (local-set-key (kbd "C-c C-x M-l")
                                            (kbd "C-u C-u C-c C-x C-l"))))

  (global-set-key (kbd "C-c a") 'org-agenda)
  (add-hook 'org-agenda-mode-hook 'delete-other-windows)

  (setq org-agenda-files (list "~/planner.org"
                               "~/schedules/Y2/Q1.org"
                               "~/homework/MA211.org"
                               "~/homework/CSSE372.org"
                               "~/homework/MA332.org"
                               "~/homework/CSSE371.org"
                               "~/homework/RH330.org"))
#+END_SRC
*** octave-mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m" . octave-mode))
#+END_SRC
*** [[https://github.com/Malabarba/paradox/][paradox]]
Allows for asynchronous installation of packages.

#+BEGIN_SRC emacs-lisp
  (req-package paradox)
#+END_SRC
*** [[https://github.com/dpsutton/resize-window][resize-window]]
Creates a new special mode where you can quickly resize any window using n-p-f-b. Makes it a lot easier to readjust things.

#+BEGIN_SRC emacs-lisp
  (req-package resize-window
    :init
    (global-set-key (kbd "C-S-r") 'resize-window))
#+END_SRC
*** [[https://github.com/Fuco1/smartparens][smartparens]]
Autobalances your parentheses as you type them. Great for Lisp programming.

#+BEGIN_SRC emacs-lisp
  (req-package smartparens
    :init
    (add-hook 'prog-mode-hook '(lambda ()
                                 (smartparens-mode 1))))
#+END_SRC
*** [[https://github.com/dimitri/switch-window][switch-window]]
Makes life so much easier when you have multiple windows open. Just hit one keyboard shortcut, press the number screen you want,
and you're there.

#+BEGIN_SRC emacs-lisp
  (req-package switch-window
    (global-set-key (kbd "s-o") 'switch-window))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]]
Shows a visual representation of your undo history as an easily navigable tree.

#+BEGIN_SRC emacs-lisp
  (req-package undo-tree
    :diminish undo-tree-mode
    :config (global-undo-tree-mode))
#+END_SRC
*** [[https://github.com/bcbcarl/emacs-wttrin][wttrin]]
A nice forecast program with some nice ASCII art for the clouds. Now I can check what the weather is like without
even looking out a window!

#+BEGIN_SRC emacs-lisp
  (req-package wttrin
    :config
    (setq wttrin-default-cities '("St. Louis" "Terre Haute"))
    (global-set-key (kbd "s-f") 'wttrin))
#+END_SRC
*** [[https://github.com/capitaomorte/yasnippet][yasnippet]]
The basically necessary snippet package. Allows you to use little snippets that expand out to save a lot of typing.
I have yasnippet to load only when opening this session's first programming file, since it takes quite a while to load on
start up.

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :diminish yas-minor-mode
    :config
    (defvar yas-loaded 0)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'prog-mode-hook
              '(lambda ()
                 (when (= yas-loaded 1)
                       (setq yas-loaded 1)
                       (yas-reload-all)))))
#+END_SRC
** Visuals
*** [[https://github.com/domtronn/all-the-icons.el][all-the-icons]]
Shows fancy looking icons on file names (looks really pretty).

#+BEGIN_SRC emacs-lisp
  (req-package all-the-icons)
#+END_SRC
*** [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]]
This makes programming files so much prettier and colorful, as it extrapolates colors from your current theme and color codes
all of your defined variables accordingly. This makes it easier to see where things are being used as well as a good syntax
checker to show that you spelled the variable correctly.

#+BEGIN_SRC emacs-lisp
  (req-package color-identifiers-mode
    :diminish color-identifiers-mode
    :config
    (global-color-identifiers-mode))
#+END_SRC
*** [[https://github.com/jordonbiondo/column-enforce-mode][column-enforce-mode]]
Highlights texts that goes beyond a certain column. Very nice for coding.

#+BEGIN_SRC emacs-lisp
  (req-package column-enforce-mode
    :config
    (add-hook 'c-mode-hook 'column-enforce-mode))
#+END_SRC
*** [[https://github.com/lunaryorn/fancy-battery.el][fancy-battery]]
Shows the current battery level as colored text in the mode line. Really nice since I start Emacs full screen and can't see
the OS's battery display.

#+BEGIN_SRC emacs-lisp
  (req-package fancy-battery)
#+END_SRC
*** [[https://github.com/sjrmanning/darkokai][darkokai]]
It's like monokai theme, but better in my opinion.
The extra line is to keep the modeline small and not stupid looking.

#+BEGIN_SRC emacs-lisp
  (req-package darkokai-theme
    :disabled t
    :require fic-mode
    :config
    (setq darkokai-mode-line-padding 1)
    (load-theme 'darkokai t))
#+END_SRC
*** [[http://elpa.gnu.org/packages/nlinum.html][nlinum]]
Like linum mode, but much, /much/, _much_ more efficient.

#+BEGIN_SRC emacs-lisp
  (req-package nlinum)
#+END_SRC
*** [[https://github.com/sabof/org-bullets][org-bullets]]
Turn org-mode bullets into fancy utf-8 symbols that make them look so much prettier. Sorry if your browser can't see some
of the beautiful symbols. Take my word for it, they're just fancy bullets.

#+BEGIN_SRC emacs-lisp
  (req-package org-bullets
    :init
    (setq org-bullets-bullet-list
          '("◉" "◎" "⚫" "○" "►" "◇"))
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/PrettySymbol][prettify-symbols-mode]]
Built into Emacs by default. This essentially changes a few keywords into pretty symbols, like changing lambda to λ in Lisp.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC
*** [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimeters]]
This package recolors parentheses, braces, and brackets in matching pairs. This makes programming so much eaier and prettier.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** [[https://github.com/k-talo/volatile-highlights.el][volatile-highlights]]
Whenever you change a large block of text, like with an undo or a yank,
this temporarily highlights it to draw attention to it.

#+BEGIN_SRC emacs-lisp
  (req-package volatile-highlights
    :diminish volatile-highlights-mode
    :config
    (volatile-highlights-mode t))
#+END_SRC
* Custom Functions
** Modeline Customization
Just making my modeline fancy.
Note that this requires the package all-the-icons.
#+BEGIN_SRC emacs-lisp
  (defvar orig-mode-line mode-line-format)
  (defvar mode-line-font-height 1.0)

  (defun reset-modeline ()
    (interactive)
    (setq mode-line-format orig-mode-line))

  (defun custom-modeline-modified ()
    (let* ((config-alist
            '(("*" all-the-icons-faicon-family all-the-icons-faicon "chain-broken" :height 1.2 :v-adjust -0.0)
              ("-" all-the-icons-faicon-family all-the-icons-faicon "link" :height 1.2 :v-adjust -0.0)
              ("%" all-the-icons-octicon-family all-the-icons-octicon "lock" :height 1.2 :v-adjust 0.1)))
           (result (cdr (assoc (format-mode-line "%*") config-alist))))
      (propertize (apply (cadr result) (cddr result))
                  'face `(:family ,(funcall (car result))))))

  (defun custom-modeline-mode-icon ()
    (format " %s"
            (let* ((icon (all-the-icons-icon-for-buffer))
                   (is-string (stringp icon))
                   (height (if is-string 1.25 1.00)))
              (propertize (if is-string icon (format "%s" major-mode))
                              'help-echo (format "Major-mode: `%s`" major-mode)
                              'face `(:foreground "dark olive green"
                                                  :height ,mode-line-font-height
                                                  :family ,(if is-string
                                                               (all-the-icons-icon-family-for-buffer)
                                                             "DejaVu Sans Mono"))))))

  (defun custom-modeline-region-info ()
    (when mark-active
      (let ((words (count-lines (region-beginning) (region-end)))
            (chars (count-words (region-end) (region-beginning))))
        (concat
         (propertize (format "   %s" (all-the-icons-octicon "pencil") words chars)
                     'face `(:family ,(all-the-icons-octicon-family))
                     'display '(raise -0.0))
         (propertize (format " (%s, %s)" words chars)
                     'face `(:height 0.9))))))

  (defun -custom-modeline-github-vc ()
    (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
      (concat
       (propertize (format " %s" (all-the-icons-alltheicon "git")) 'face `(:height 1.2 :family ,(all-the-icons-octicon-family)) 'display '(raise -0.1))
       " · "
       (propertize (format "%s" (all-the-icons-octicon "git-branch"))
                   'face `(:height 1.3 :family ,(all-the-icons-octicon-family))
                   'display '(raise -0.1))
       (propertize (format " %s" branch) 'face `(:height 0.9)))))

  (defun -custom-modeline-svn-vc ()
    (let ((revision (cadr (split-string vc-mode "-"))))
      (concat
       (propertize (format " %s" (all-the-icons-faicon "cloud")) 'face `(:height 1.2) 'display '(raise -0.1))
       (propertize (format " · %s" revision) 'face `(:height 0.9)))))

  (defun custom-modeline-icon-vc ()
    (when vc-mode
      (cond
       ((string-match "Git[:-]" vc-mode) (-custom-modeline-github-vc))
       ((string-match "SVN-" vc-mode) (-custom-modeline-svn-vc))
       (t (format "%s" vc-mode)))))

  (defun customize-modeline ()
      (interactive)
      (setq-default mode-line-format
                    '(concat " %e"
                             (:eval
                              (concat
                               (propertize (custom-modeline-modified)
                                           'face
                                           `(:foreground "pink" :height ,mode-line-font-height))
                               (propertize " %I"
                                           'face
                                           `(:foreground "firebrick" :height ,mode-line-font-height))
                               (propertize " %z | "
                                           'face
                                           `(:height ,mode-line-font-height))
                               (propertize "%l"
                                           'face
                                           `(:foreground "tomato" :height ,mode-line-font-height))
                               (propertize ":"
                                           'face
                                           `(:height ,mode-line-font-height))
                               (propertize "%c"
                                           'face
                                           `(:foreground "gold" :height ,mode-line-font-height))
                               (propertize " %p"
                                           'face
                                           `(:foreground "medium purple" :height ,mode-line-font-height))
                               (propertize " |"
                                           'face
                                           `(:height ,mode-line-font-height))
                               (custom-modeline-mode-icon)
                               " "
                               (propertize (buffer-name)
                                           'face
                                           `(:foreground "white" :height ,mode-line-font-height))
                               " |"
                               (let ((text (custom-modeline-icon-vc)))
                                 (if text
                                     (concat
                                      (propertize text
                                                  'face
                                                  `(:foreground "orange" :height ,mode-line-font-height))
                                      " | ")))))
                             (:eval mode-line-modes))))

  (customize-modeline)
#+END_SRC
** Clean Buffer
#+BEGIN_SRC emacs-lisp
  (defun clean-buffer ()
    "Reindent the whole buffer."
    (interactive)
    (indent-region (point-min) (point-max)))
#+END_SRC
** Update Doxygen
#+BEGIN_SRC emacs-lisp
  (defun update-doxygen ()
    "Check to see if there is a Doxyfile in the current directory.
  If it does, update the file.  If not, generate a new Doxyfile."
    (interactive)
    (if (file-exists-p "Doxyfile")
        (shell-command "doxygen Doxyfile > /dev/null")
      (progn
        (shell-command "doxygen -g > /dev/null; doxygen Doxyfile > /dev/null")
        (message "Created new Doxyfile"))))
#+END_SRC
** Hex Coloring
Changes the font color of colors to easily determine what they are.
Taken from http://ergoemacs.org/emacs/elisp_eval_lisp_code.html

#+BEGIN_SRC emacs-lisp
  (defun xah-syntax-color-hex ()
    "Syntax color hex color spec such as 「#ff1100」 in current buffer."
    (interactive)
    (font-lock-add-keywords
     nil
     '(("#[abcdef[:digit:]]\\{6\\}"
        (0 (put-text-property
            (match-beginning 0)
            (match-end 0)
            'face (list :background (match-string-no-properties 0)))))))
    (font-lock-fontify-buffer))
#+END_SRC
** Save Spelling to Dictionary
Basically uses ispell on the previous misspelled word, and stores the change
into abbrev for future autocorrection.
http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

#+BEGIN_SRC emacs-lisp
  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev.  Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer.  You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (thing-at-point 'word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word))
        (setq aft (thing-at-point 'word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
#+END_SRC
** Actually Quit Minibuffer
#+BEGIN_SRC emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
#+END_SRC
** Move to Start of Text
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (defun sk/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.
  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.
  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+END_SRC
** Select Current Line
#+BEGIN_SRC emacs-lisp
  (defun sk/select-current-line ()
    "Select the current line.
  Stolen from http://sriramkswamy.github.io/dotemacs/#orgheadline18."
    (interactive)
    (sk/smarter-move-beginning-of-line 1)
    (set-mark (line-end-position))
    (exchange-point-and-mark))
#+END_SRC
** Auto-correct DOuble CAps
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (defun sk/dcaps-to-scaps ()
    "Convert word in DOuble CApitals to Single Capitals."
    (interactive)
    (and (= ?w (char-syntax (char-before)))
         (save-excursion
           (and (if (called-interactively-p)
                    (skip-syntax-backward "w")
                  (= -3 (skip-syntax-backward "w")))
                (let (case-fold-search)
                  (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                (capitalize-word 1)))))
#+END_SRC
** Open URL in Conkeror
I really like Conkeror if literally only for the keyboard-based browsing. It’s
really clunky, though, so I need to manually call it here. Don’t ask why.

#+BEGIN_SRC emacs-lisp
  (defun open-url-conkeror (url)
    (shell-command
     (concat "conkeror " (format "%s" url))))
#+END_SRC
** Open in External Program
Just open the current file in whatever the default program is for it’s type.
This is mostly intended for opening HTML’s, PDF’s, and LibreOffice files, but
there’s a chance it won’t terribly mess up with other types of files.

#+BEGIN_SRC emacs-lisp
  (defun open-external ()
    "Open current file in default external program."
    (interactive)
    (when buffer-file-name
      (shell-command (concat
                      "xdg-open "
                      (shell-quote-argument buffer-file-name)
                      " &"))))

  (global-set-key (kbd "C-c o") 'open-external)
#+END_SRC
** Save and Restore Scratch Buffer
It’s kind of nice /not/ completely blowing away the scratch buffer whenever I
kill Emacs. This code from [[https://github.com/dakrone/eos/blob/master/eos-core.org][here]] should save it every minute and whenever Emacs
dies as well as reload it upon boot-up.

#+BEGIN_SRC emacs-lisp
  (defun save-persistent-scratch ()
    "Write the contents of *scratch* to the file name
  `persistent-scratch-file-name'."
    (with-current-buffer (get-buffer-create "*scratch*")
      (write-region (point-min) (point-max) "~/.emacs.d/persistent-scratch")))

  (defun load-persistent-scratch ()
    "Load the contents of `persistent-scratch-file-name' into the
  scratch buffer, clearing its contents first."
    (if (file-exists-p "~/.emacs.d/persistent-scratch")
        (with-current-buffer (get-buffer "*scratch*")
          (delete-region (point-min) (point-max))
          (insert-file-contents "~/.emacs.d/persistent-scratch"))))

  (add-hook 'after-init-hook 'load-persistent-scratch)
  (add-hook 'kill-emacs-hook 'save-persistent-scratch)
#+END_SRC
* Custom Minor Modes
** Dubcaps Mode
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (define-minor-mode sk/dubcaps-mode
    "Toggle `sk/dubcaps-mode'.  Converts words in DOuble CApitals to
  Single Capitals as you type."
    :init-value nil
    :lighter (" DC")
    (if sk/dubcaps-mode
        (add-hook 'post-self-insert-hook #'sk/dcaps-to-scaps nil 'local)
      (remove-hook 'post-self-insert-hook #'sk/dcaps-to-scaps 'local)))

  (add-hook 'text-mode-hook #'sk/dubcaps-mode)
  (add-hook 'org-mode-hook #'sk/dubcaps-mode)
#+END_SRC
** Doxygen Mode
My personal creation that just updates doxygen whenever you save the current file.
#+BEGIN_SRC emacs-lisp
  (define-minor-mode doxygen-mode
    "Update the Doxyfile after each save."
    :lighter " Doxygen"
    (add-hook 'after-save-hook 'update-doxygen))
#+END_SRC
* Custom Keybinds
Note that there are plenty more scattered around, so this is more for built-in
or custom functions.
** Motion and Formatting
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-a") 'sk/smarter-move-beginning-of-line)
  (global-set-key (kbd "s-v") 'sk/select-current-line)
  (global-set-key (kbd "s-r") 'clean-buffer)
#+END_SRC
** Programming
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c /") 'comment-line)
  (global-set-key (kbd "C-c C-/") 'comment-or-uncomment-region)
  (global-set-key (kbd "<f5>") 'compile)
#+END_SRC
** Start Applications
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-t") 'ansi-term)
  (global-set-key (kbd "s-b") 'eww)
  (global-set-key (kbd "s-c") 'calc)
#+END_SRC
** Strengthen Escape
#+BEGIN_SRC emacs-lisp
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC
* Yet Another Modal Mode (YAM)
This is really more of a lisp experiment on my part, so this may get ugly.
I used to use Evil mode, and while I’ve looked at what replacements are there,
such as modalka and ryo-modal, but they’re all missing the ability to define
meaningfully different modes like the Normal / Visual modes in Vim. This hopes
to take the best parts of those modes and create my own with this added
functionality.

#+BEGIN_SRC emacs-lisp
  (require 'yam-mode "~/.emacs.d/yam-mode.el")
#+END_SRC
* Bucket List
Things I'd like to fix/improve when I have the time and know-how.

** Cool Packages
- https://github.com/twada/coverlay.el
  - shows code coverage according to an lcov file
** Java
- find a nice syntax checker
** Speed up theme loading
- color-theme-x might help, it just doesn't work too well
** Better IDE-style things?
- maybe [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][CEDET]] or irony?
** New unicode input method
Char-menu is nice, but it's kind of hard to memorize its tree. LaTeX-style insert
is also nice, but it's often really clunky with things like \bigtriangledown.
If I can somehow set up a LaTeX shorthand like \btd = \bigtriangledown, then life
should be better.
