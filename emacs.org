* Overview
This is my personal setup for Emacs. Most everything should work right out of the box, but one may need to do some fanagling to get it to work the first time.
This whole setup essentially hinges on req-package, use-package's slightly more robust sibling. \\
One thing to note is that I use the Colemak keyboard layout, which means some of my keybindings may seem a little weird. I've thought of this and created a flag called
=flag-colemak= in init.el. If you want to use more QWERTY bindings, set that to 0 instead of 1. These other bindings will be listed
in [ ] next to the defaults. \\
I also use the super key (s- ) in a lot of my bindings. If you want to use them as-is, you need to look into getting the key to work
properly on your OS.
* General Settings
** Hide Make Buffers
I don't really like having a new window pop up to tell me what happened during a make.
This makes it so that the minibuffer tells you whether the compilation succeeded or failed.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'display-buffer-alist '("*compilation*" . (display-buffer-no-window)))
#+END_SRC
** Make Magit Buffer Big
When calling Magit status, usually the buffer only takes up half the screen, which isn't really pretty.
This makes it so that doesn't happen.
This is taken from http://www.lunaryorn.com/2016/04/28/fullscreen-magit-status.html.

#+BEGIN_SRC emacs-lisp
  (defun my-display-buffer-fullframe (buffer alist)
    "Display BUFFER in fullscreen.
  ALIST is a 'display-buffer' ALIST."
    (let ((window (or (display-buffer-use-some-window buffer alist)
                      (display-buffer-pop-up-window buffer alist))))
      (when window
        (delete-other-windows window)
        window)))

  (add-to-list 'display-buffer-alist
               `(,(rx "*magit: ")
                 (my-display-buffer-fullframe)
                 (reusable-frames . nil)))
#+END_SRC
** Set Default Browser To Conkeror
Conkeror is quick and I have some nice keybindings for it.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "~/scripts/conkeror.sh")
#+END_SRC
** Overwrite Selected Text
Emacs usually deselects a region once you start typing, but I like it to delete the selected text in that case.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC
* Package List
** Control
*** [[https://github.com/abo-abo/avy][avy]]
A lovely package that allows you to quickly jump to wherever you want to go practically instantly.
- keybinds:
  + M-s - use avy with one word
  + M-l - use avy to go to a line
#+BEGIN_SRC emacs-lisp
  (req-package avy
    :bind
    (("M-s" . avy-goto-word-1)
     ("M-S-s" . avy-goto-char-2)
     ("M-l" . avy-goto-line)))
#+END_SRC
*** [[https://github.com/joodland/bm][bm]]
An extremely simple yet really helpful package that allows you to mark multiple different positions in a file and cycle through
them with ease. Really useful when you need to go looking for something but want to save your spot, or if you keep bouncing
between a few spots in a file.
#+BEGIN_SRC emacs-lisp
  (req-package bm ;;make bookmarks and cycle through them
    :config
    (global-set-key (kbd "s-d") 'bm-toggle)
    (if (= flag-colemak 1)
        (progn
          (global-set-key (kbd "C-M-n") 'bm-next)
          (global-set-key (kbd "C-M-p") 'bm-previous))
      (progn
        (global-set-key (kbd "s-j") 'bm-next)
        (global-set-key (kbd "s-k") 'bm-previous))))
#+END_SRC    
*** [[https://github.com/abo-abo/swiper][counsel]]
#+BEGIN_SRC emacs-lisp
  (req-package counsel)
  (global-set-key (kbd "M-x") 'counsel-M-x)
#+END_SRC
*** [[https://github.com/knu/elscreen][elscreen]]
You know how Emacs does multiple windows? Poorly, in my opinion. Why would you ever want to deal with layers of windows you 
can't see when you could just have different tabs that you can easily switch between that function identically to having
separate windows? With this, you can very quickly tell what all you have open in your other tabs and quickly jump to whichever
you want.
#+BEGIN_SRC emacs-lisp
  (use-package elscreen
    :disabled t
    :ensure t ;; this has to be use-package to make it work for some reason
    :init
    ;;(elscreen-start)
    ;; set up tab commands
    (global-set-key (kbd "C-c 0") 'elscreen-kill)
    (global-set-key  (kbd "C-c 1") 'elscreen-kill-others)
    (global-set-key  (kbd "C-c 2") 'elscreen-create)
    (global-set-key  (kbd "C-c o") 'elscreen-next)
    (global-set-key  (kbd "C-c h") 'elscreen-previous)
    (global-set-key (kbd "C-c s-o") 'elscreen-goto))
#+END_SRC
*** [[https://bitbucket.org/lyro/evil/wiki/Home][evil]]
Gets me out of a lot of text editor wars and allows me to use slightly less insane bindings for moving around.

#+BEGIN_SRC emacs-lisp
    (req-package evil ;;TODO Speed up
      :disabled t
      :config
      (global-set-key (kbd "s-e") 'evil-mode)
      (evil-set-initial-state 'blackbox-mode 'emacs)
      (evil-set-initial-state 'package-menu-mode 'motion)
      (evil-set-initial-state 'org-agenda-mode 'motion)
      (evil-set-initial-state 'elfeed-show-mode 'emacs)
      (evil-set-initial-state 'elfeed-search-mode 'emacs)
      (evil-set-initial-state 'dired-mode 'emacs)
      (evil-set-initial-state 'doc-view-mode 'emacs)
      (add-hook 'forecast-mode-hook 'evil-emacs-state)

      (setq evil-move-cursor-back nil) ;; Make it so the cursor doesn't pop back when leaving insert mode.

      (if (= flag-colemak 1)
          (progn
            (colemak-evil-normal-state-remap)
            (colemak-evil-visual-state-remap)
            (colemak-evil-motion-state-remap))
        (progn
          (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
          (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line))))
#+END_SRC
*** [[https://github.com/cofi/evil-leader][evil-leader]]
Allows me to set a <leader> key, for me the spacebar, to use for another set of keybindings. Really useful for common operations
I do a lot, like saving for instance.

#+BEGIN_SRC emacs-lisp
  (req-package evil-leader
    :require evil quickrun
    :disabled t
    :init
    (setq evil-leader/in-all-states 1)
    (global-evil-leader-mode)
    :config
    (evil-leader/set-leader "SPC")
    (evil-leader/set-key
      "0" 'delete-window
      "1" 'delete-other-windows
      "2" 'split-window-below
      "3" 'split-window-right
      "f" 'find-file
      "D" 'divide-evenly
      "d" 'ido-dired
      "s" 'save-buffer
      "o" 'other-window
      "O" 'switch-window
      "l" 'ispell-buffer
      "L" 'endless/ispell-word-then-abbrev
      "k" 'goto-last-change
      "j" 'goto-last-change-reverse
      "b" 'ido-switch-buffer
      "r" 'quickrun
      "x" 'smex))
#+END_SRC
*** [[https://github.com/gabesoft/evil-mc][evil-mc]]
Turns all those sublime text users' principle argument against Emacs on it's head and gives Emacs multiple cursors.
Some of these keybindings overwrite standard Emacs motion keys.
- keybinds
  + g r h - create a new cursor at this location
  + g r u - remove all cursors
  + g r m - create cursors at all matching strings
  + C-p - make a new cursor at the current match and go to the previous match
  + C-t - go to next match
  + C-n - make a new cursor at the current match and go to the next match
    
#+BEGIN_SRC emacs-lisp
  (req-package evil-mc
    :require evil
    :disabled t
    :diminish evil-mc-mode)
#+END_SRC
*** [[https://github.com/magnars/expand-region.el][expand-region]]
Gives the ability to quickly create and expand a region to fill some kind of
boundary, like parentheses or quotes. This gives Emacs something like the
functionality of Vim with its "change-in" commands.

#+BEGIN_SRC emacs-lisp
  (req-package expand-region
    :config
    (global-set-key (kbd "M-i") 'er/expand-region)
    ;; This just does the same in reverse.
    (global-set-key (kbd "M-r") (lambda ()
                                  (interactive)
                                  (setq current-prefix-arg '(-1))
                                  (call-interactively 'er/expand-region))))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/InteractivelyDoThings][ido]]
Allows for more autocompletion when searching for files.

#+BEGIN_SRC emacs-lisp
    (req-package ido
      :disabed t
      :init
      (ido-mode t)
      (setq ido-default-buffer-method 'selected-window))
#+END_SRC
*** [[https://github.com/abo-abo/swiper][ivy]]
This is a generic completion package that is used as a backend for swiper.
It pulls up a larger minibuffer that shows all the possible completions.

#+BEGIN_SRC emacs-lisp
  (req-package ivy
    :diminish ivy-mode
    :config
    (setq ivy-use-virtual-buffers t)
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy))) ;; Use fuzzy matching
    (define-key ivy-minibuffer-map (kbd "C-p") 'ivy-previous-line)
    (define-key ivy-minibuffer-map (kbd "C-n") 'ivy-next-line)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (ivy-mode 1))
#+END_SRC
*** [[https://github.com/abo-abo/hydra][hydra]]
This lovely package allows for improved use of chaining similar commands.
I'll be trying to use it to wean myself off of some of the features
of evil-mode, but I'm sure I'll keep both installed for a while.

#+BEGIN_SRC emacs-lisp
  (req-package hydra
    :config
    (defhydra hydra-motion (:body-pre (next-line))
      "motion"
      ("b" backward-char "←")
      ("n" next-line "↓")
      ("p" previous-line "↑")
      ("f" forward-char "→")
      ("a" beginning-of-line "BoL")
      ("e" move-end-of-line "EoL")
      ("P" scroll-down-command "Pg ↓")
      ("N" scroll-up-command "Pg ↑")
      ("B" backward-word "←←")
      ("F" forward-word "→→")
      ("l" recenter-top-bottom "Center")
      ("G" end-of-buffer "EoF")
      ("g" beginning-of-buffer "BoF"))
    (global-set-key (kbd "C-n") #'hydra-motion/next-line)
    (global-set-key (kbd "C-p") #'hydra-motion/previous-line)
    (global-set-key (kbd "C-f") #'hydra-motion/forward-char)
    (global-set-key (kbd "C-b") #'hydra-motion/backward-char))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/KeyChord][key-chord]]
Allows the ability to define different key chords, key combinations
that trigger an action when pressed in quick succession.

#+BEGIN_SRC emacs-lisp
  (req-package key-chord
    :config
    (setq key-chord-one-key-delay 0.2)
    (setq key-chord-two-key-delay 0.2)
    (key-chord-define c-mode-map ".." "->")
    (key-chord-define c++-mode-map ".." "->")
    (key-chord-define global-map "-." "→")
    (key-chord-define-global ",-" "←")
    (key-chord-define-global "--" "_")
    (key-chord-define-global "vf" 'find-file)
    (key-chord-define-global "vu" 'undo)
    (key-chord-define-global "vs" 'save-buffer)
    (key-chord-define-global "vl" 'ispell-region)
    (key-chord-define-global "VL" 'endless/ispell-word-then-abbrev)
    (key-chord-define-global "vn" #'hydra-motion/next-line)
    (key-chord-mode 1))
#+END_SRC
*** [[http://elpa.gnu.org/packages/smart-yank.html][smart-yank]]
Makes yanking a little smarter. For one thing, when doing a yank-pop, it moves the cut that you've
popped to the top of the ring to make it easier the next time, while it also resets the stack position
upon any command rather than only on kills.

#+BEGIN_SRC emacs-lisp
  (req-package smart-yank
    :config
    (smart-yank-mode 1))
#+END_SRC
*** [[https://github.com/nonsequitur/smex][smex]]
Uses ido completion when using M-x.

#+BEGIN_SRC emacs-lisp
  (req-package smex
    :disabled t
    :config
    (smex-initialize)
    (global-set-key (kbd "M-x") 'smex))
#+END_SRC
*** [[https://github.com/abo-abo/swiper][swiper]]
This basically extends ivy-mode to provide a comprehensive overview of whatever you're
searching for.

#+BEGIN_SRC emacs-lisp
  (req-package swiper
    :requires ivy
    :config
    (global-set-key (kbd "C-s") 'swiper))
#+END_SRC
*** [[https://github.com/tlinden/viking-mode][viking-mode]]
Hillariously named and actually quite useful. This package quickly deletes first the word, then line
remainder, the whole line, the paragraph, and finally the whole buffer.

It also provides a nice variable that tracks how many times the last key was consecutively pressed, which might
be fun to work with.

#+BEGIN_SRC emacs-lisp
  (req-package viking-mode
    :disabled t
    :config
    (viking-global-mode)
    (define-key viking-mode-map (kbd "C-d") 'viking-kill-thing-at-point))
#+END_SRC
*** [[https://github.com/mrkkrp/zzz-to-char][zzz-to-char]]
Visually kill a part of a line, forward or backward, to a given character.
This in some ways shoots Vim's kill-to command out of the water, simply
because of how easy it is to go to a specific instance of a character with
an avy backend.

#+BEGIN_SRC emacs-lisp
  (req-package zzz-to-char
    :requires avy
    (global-set-key (kbd "M-z") 'zzz-up-to-char)
    (global-set-key (kbd "M-Z") 'zzz-to-char))
#+END_SRC
** Programming
*** [[https://www.emacswiki.org/emacs/CcMode][cc-mode]]
Built into Emacs. I'm just putting this here to establish a few start up hooks. I have individual setups for each C-type mode,
just so that they actually work.

#+BEGIN_SRC emacs-lisp
  (setq-default c-basic-offset 2)
  (setq-default c++-basic-offset 2)

  (add-hook 'cc-mode-common-hook '(lambda ()
                                    (add-to-list 'ac-sources 'ac-source-semantic)))
  (add-hook 'c-mode-common-hook '(lambda ()
                                   (add-to-list 'ac-sources 'ac-source-semantic)))
  (add-hook 'c++-mode-common-hook '(lambda ()
                                       (add-to-list 'ac-sources 'ac-source-semantic)))

  (add-hook 'cc-mode-hook 'semantic-mode)
  (add-hook 'c-mode-hook 'semantic-mode)
  (add-hook 'c++-mode-hook 'semantic-mode)

#+END_SRC
*** [[https://github.com/jscheid/dtrt-indent][dtrt-indent]]
This is an especially useful package when editing code that somebody else wrote, as it automatically detects what the
indentation size is and sets yours to match.

#+BEGIN_SRC emacs-lisp
  (req-package dtrt-indent)
#+END_SRC
*** [[https://github.com/lewang/fic-mode][fic-mode]]
Another tiny yet remarkably helpful package that just highlights keywords like TODO or FIXME in comments.
It is currently turned on in any prog-mode. Someday I should just write something like this myself, both for experience
and so that this doesn't keep slowing down my boot up time.

#+BEGIN_SRC emacs-lisp
  (req-package fic-mode
    :diminish fic-mode
    :config
    (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC
*** [[https://github.com/flycheck/flycheck][flycheck]]
A magic little syntax checker for various languages like C. It sets a compiler flag for gnu11, since my computer doesn't
compile for loops and the like by default for some reason. Triggered in any prog-mode.

#+BEGIN_SRC emacs-lisp
  (defun setup-flycheck-rtags ()
    (interactive)
    "Stolen from https://vxlabs.com/tag/rtags/."
    (flycheck-select-checker 'rtags)
    (setq-local flycheck-highlighting-mode nil)
    (setq-local flycheck-check-syntax-automatically nil))

  (req-package flycheck
    :require rtags
    :config
    (flycheck-set-checker-executable 'c/c++-gcc "/usr/bin/gcc")
    (setq flycheck-gcc-args "-std=gnu11")

    (when (require 'rtags nil :noerror)
      (require 'company)
      (define-key c-mode-base-map (kbd "s-n")
        (function rtags-find-symbol-at-point))
      (define-key c-mode-base-map (kbd "s-k")
        (function rtags-find-references-at-point))
      (rtags-enable-standard-keybindings)
      (setq rtags-autostart-diagnostics t)
      (rtags-diagnostics)
      (setq rtags-completions-enabled t)
      (push 'company-rtags company-backends)
      (global-company-mode t)
      (define-key c-mode-base-map (kbd "<C-tab>")
        (function company-complete))
      (require 'flycheck-rtags)
      (add-hook 'c-mode-common-hook #'setup-flycheck-rtags))

    (add-hook 'prog-mode-hook 'flycheck-mode))
#+END_SRC
*** [[https://github.com/leoliu/ggtags][ggtags]]
C/C++ program tagging. This allows one to easily jump around a program to definitions and usages of variables and functions.
- keybinds:
  + M-g M-g - go to either the definition or usage of the symbol at point
  + M-g r - return to the last point jumped from
    
#+BEGIN_SRC emacs-lisp
(req-package ggtags
  :diminish ggtags-mode
  :config
  (add-hook 'c-mode-hook #'ggtags-mode)
  (add-hook 'c++-mode-hook #'ggtags-mode)
  (add-hook 'cc-mode-hook #'ggtags-mode)
  (add-hook 'java-mode-hook #'ggtags-mode)
  (add-hook 'asm-mode-hook #'ggtags-mode)
  (define-key ggtags-mode-map (kbd "M-g M-g") #'ggtags-find-tag-dwim)
  (define-key ggtags-mode-map (kbd "M-g r") #'ggtags-prev-mark))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/HideShow][hs]]
A very effective code folding package that is started in any prog-mode.
    
#+BEGIN_SRC emacs-lisp
  (add-hook 'hs-minor-mode-hook '(lambda () (diminish 'hs-minor-mode)))
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (global-set-key (kbd "C-c C-f") 'hs-toggle-hiding)
#+END_SRC
*** lisp-mode
Built into Emacs (or more specifically, builds Emacs) by default. Right now I'm just specifying .stumpwmrc should be in lisp mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '(".stumpwmrc" . lisp-mode))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/MakefileMode][makefile-mode]]
Built into Emacs by default. I'm just adding Doxyfiles to make them more readable.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("Doxyfile" . makefile-mode))
#+END_SRC
*** [[https://github.com/bbatsov/projectile][projectile]]
Helps finding files in a given project. I'm not entirely sure if or how this is working, so I'll fiddle around with it.

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :diminish projectile-mode
    :requires ivy
    :init
    (projectile-global-mode)
    (setq projectile-enable-caching t)
    (setq projectile-completion-system 'ivy))
#+END_SRC
*** [[https://github.com/syohex/emacs-quickrun][quickrun]]
Ever wanted to just compile and run a program with one short keystroke? This allows you to do just that.

#+BEGIN_SRC emacs-lisp
  '(add-hook 'prog-mode-hook
             '(lambda ()
                (require 'quickrun)
                (quickrun-add-command "c/gcc"
                                      '((:command . "gcc")
                                        (:exec . ("%c %o -std=gnu11 -o %e %s" "%e")))
                                      :override t)))
#+END_SRC
*** scheme-mode
A lot of these settings are from the default config for my CSSE304 class.
I am using petite chez as my interpereter, as it is required for the class.

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq scheme-program-name "petite")

  (put 'eval-when     'scheme-indent-function 1)
  (put 'set!          'scheme-indent-function 1)
  (put 'when          'scheme-indent-function 1)
  (put 'unless        'scheme-indent-function 1)
  (put 'record-case   'scheme-indent-function 1)
  (put 'c-record-case 'scheme-indent-function 1)
  (put 'variant-case  'scheme-indent-function 1)
  (put 'parameterize  'scheme-indent-function 1)
  (put 'call-with-values 'scheme-indent-function 1)
  (put 'extend-syntax 'scheme-indent-function 1)
  (put 'with          'scheme-indent-function 1)
  (put 'let        'scheme-indent-function 1)
  (put 'let-syntax    'scheme-indent-function 1)
  (put 'letrec-syntax 'scheme-indent-function 1)
  (put 'with-syntax   'scheme-indent-function 1)
  (put 'syntax-case   'scheme-indent-function 2)
  (put 'syntax  'scheme-indent-function 1)
  (put 'syntax-rules  'scheme-indent-function 1)
  (put 'foreign-procedure 'scheme-indent-function 1)
  (put 'set-top-level-value! 'scheme-indent-function 1)
  (put 'make-parameter 'scheme-indent-function 1)
  (put 'decompose     'scheme-indent-function 2)
  (put 'mvlet         'scheme-indent-function 1)
  (put 'mvlet*        'scheme-indent-function 1)
  (put 'state-case    'scheme-indent-function 1)
  (put 'foreach       'scheme-indent-function 1)
  (put 'vector-foreach 'scheme-indent-function 1)
  (put 'assert        'scheme-indent-function 1)
  (put 'fold-list     'scheme-indent-function 2)
  (put 'fold-vector   'scheme-indent-function 2)
  (put 'fold-count    'scheme-indent-function 2)
  (put 'on-error      'scheme-indent-function 1)
#+END_SRC
*** [[http://www.gnu.org/software/emacs/manual/html_node/semantic/index.html][semantic]]
Built into Emacs by default. Sets the refresh time and some keybinds.

#+BEGIN_SRC emacs-lisp
  (req-package semantic
    :init
    (global-semanticdb-minor-mode 1)
    (global-semantic-idle-scheduler-mode 1)
    (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
    (global-set-key (kbd "M-g TAB") 'semantic-complete-analyze-inline)
    (global-set-key (kbd "M-g g") 'semantic-complete-jump-local))
#+END_SRC
*** stumpwm-mode
Since I use StumpWM, this should come in handy.

#+BEGIN_SRC emacs-lisp
  (req-package stumpwm-mode
    :config
    (add-to-list 'auto-mode-alist '(".stumpwmrc" . stumpwm-mode)))
#+END_SRC
** Usability
*** [[https://github.com/cdominik/cdlatex][cdlatex]]
Provides quick shortcuts for lots of long latex symbols. For example, `a turns into =\alpha=.

#+BEGIN_SRC emacs-lisp
(req-package cdlatex
  :diminish cdlatex-mode
  :require auctex)
#+END_SRC
*** [[https://github.com/mrkkrp/char-menu][char-menu]]
Allows you to build your own tree of special characters that can be accessed via an avy-menu...menu.
    
#+BEGIN_SRC emacs-lisp
  (req-package char-menu
    :init
    (setq char-menu '("‘’" "“”" "…" "⌊⌋" "⋀" "⋁" "√"))
    (global-set-key (kbd "M-o") 'char-menu))
#+END_SRC
*** [[https://github.com/darksmile/cheatsheet/][cheatsheet]]
Just shows a quick list of handwritten keybindings and descriptions that you can pull up whenever you want. This section
makes heavy usage of the =(substitute-command-keys)= function, which looks to see whatever the command is currently bound
to and uses its string. This means I don't have to rewrite this whenever I rebind keys.

#+BEGIN_SRC emacs-lisp
  (req-package cheatsheet ;;Allows you to make a small cheatsheet of different keyboard shortcuts.
    :requires avy semantic hs resize-window flycheck
    :config
    (cheatsheet-add
     :group 'Motion
     :key (substitute-command-keys "\\[avy-goto-char-2]")
     :description "Jump to a 2-character sequence.")
    (cheatsheet-add
     :group 'Motion
     :key (substitute-command-keys "\\[avy-goto-line]")
     :description "Jump to a line.")
    (cheatsheet-add
     :group 'Tags
     :key "M-g M-g"
     :description "Jump to the definition of the symbol under the cursor.")
    (cheatsheet-add
     :group 'Tags
     :key "M-g r"
     :description "Jump back to the previous jump origin.")
    (cheatsheet-add
     :group 'Tags
     :key (substitute-command-keys "\\[semantic-complete-jump-local]")
     :description "Prompt for a function, then jump to the definition.")
    (cheatsheet-add
     :group 'Programming
     :key (substitute-command-keys "\\[hs-toggle-hiding]")
     :description "Toggle code folding.")
    (cheatsheet-add
     :group 'Common
     :key (substitute-command-keys "\\[resize-window]")
     :description "Enter resize-window mode.")
    (cheatsheet-add
     :group 'Programming
     :key (substitute-command-keys "\\[flycheck-next-error]")
     :description "Go to the next error in this program.")
    (cheatsheet-add
     :group 'Common
     :key (substitute-command-keys "\\[flyspell-mode]")
     :description "Toggle flyspell mode in this buffer.")
    (global-set-key (kbd "C-h h") 'cheatsheet-show))
#+END_SRC
*** [[https://github.com/company-mode/company-mode][company]]
Autocomplete that goes with just about everything. This is currently enabled globally.

#+BEGIN_SRC emacs-lisp
  (req-package company ;;TODO Speed up
    :diminish company-mode
    :config
    (global-company-mode))
#+END_SRC
*** [[https://github.com/Malabarba/conkeror-minor-mode][conkeror-mode]]
This allows you to send lines to conkeror to be evaluated live.

#+BEGIN_SRC emacs-lisp
  (req-package conkeror-minor-mode
    :config
    (add-hook 'js-mode-hook (lambda ()
                              (when (string= ".conkerorrc" (buffer-name))
                                (conkeror-minor-mode 1))))
    (setq conkeror-file-path "~/programs/conkeror/application.ini"))
#+END_SRC
*** [[https://github.com/myrjola/diminish.el][diminish]]
Allows you to stop showing the name of specific minor modes.

#+BEGIN_SRC emacs-lisp
  (req-package diminish)
#+END_SRC
*** [[https://github.com/skeeto/elfeed][elfeed]]
An RSS reader that loads from elfeed.org. Basically I use it to check GitHub and various Emacs sites.
- keybinds:
  + g - (in elfeed mode) refresh the feed
  + r - (in elfeed mode) mark as read
  + u - (in elfeed mode) mark as unread
    
#+BEGIN_SRC emacs-lisp
  (req-package elfeed
    :config
    (global-set-key (kbd "s-l") 'elfeed))
#+END_SRC
*** [[https://github.com/remyhonig/elfeed-org][elfeed-org]]
Allows you to define your RSS feeds in an org file, which makes it so much more readable.

#+BEGIN_SRC emacs-lisp
  (req-package elfeed-org
    :require elfeed
    :config
    (elfeed-org))
#+END_SRC
*** [[https://github.com/lewang/flx][flx-ido]]
Does some nice fuzzy matching when looking for files or buffers.

#+BEGIN_SRC emacs-lisp
  (req-package flx-ido
    :disabled t
    :init
    (ido-mode 1)
    (ido-everywhere 1)
    (flx-ido-mode 1)
    ;; disable ido faces to see flx highlights.
    (setq ido-enable-flex-matching t)
    (setq ido-use-faces nil))
#+END_SRC

*** [[https://www.emacswiki.org/emacs/FlySpell][flyspell]]
Built into Emacs by default. I only take this opportunity to set a quick keybind.

#+BEGIN_SRC emacs-lisp
  (req-package flyspell
    (global-set-key (kbd "C-c l") 'flyspell-mode))
#+END_SRC

*** [[https://github.com/cadadr/forecast.el][forecast]]
Shows the forecast for the next week in a new buffer. Perfect for when you haven't seen the light of day for a week.
This does need an API key that I have stored in another file (no, you can't have it).

#+BEGIN_SRC emacs-lisp
    (req-package forecast
      :init
      (setq forecast-latitude 39.4665
            forecast-longitude -87.4132
            forecast-city "Terre Haute"
            forecast-country "USA"
            forecast-units 'us)
      (load (locate-user-emacs-file "forecast-api-key.el"))
      (global-set-key (kbd "s-f") 'forecast))
#+END_SRC

*** [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]
When editing a file under version control, this shows little markers indicating if a line has been added, modified, or deleted.

#+BEGIN_SRC emacs-lisp
  (req-package git-gutter-fringe
    :diminish git-gutter-mode
    :init
    (global-git-gutter-mode 1))
#+END_SRC

*** [[https://github.com/dacap/keyfreq][keyfreq]]
Keeps track of all the commands you've used by frequency.

#+BEGIN_SRC emacs-lisp
    (req-package keyfreq
      :config
      (keyfreq-mode 1)
      (keyfreq-autosave-mode 1)
      (setq keyfreq-excluded-commands
            '(save-buffer
              self-insert-command)))
#+END_SRC
*** [[https://github.com/magit/magit][magit]]
The best way to use git with Emacs. Period.

#+BEGIN_SRC emacs-lisp
  (req-package magit ;;git porcelain
    :init
    (setq magit-restore-window-configuration t)
    (setq magit-completing-read-function 'ivy-completing-read)
    (global-set-key (kbd "s-g") 'magit-status)
    (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))
#+END_SRC
*** mu4e
Email manager.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-sent-messages-behavior 'sent
        mu4e-get-mail-command "fetchmail -d0"
        message-kill-buffer-on-exit t
        mu4e-view-show-images t
        mu4e-show-images t
        mu4e-view-image-max-width 800)


  ;; (setq mu4e-html2text-command "html2text -utf8 -width 72") ;; nil "Shel command that converts HTML
  ;; ref: http://emacs.stackexchange.com/questions/3051/how-can-i-use-eww-as-a-renderer-for-mu4e
  (defun my-render-html-message ()
    (let ((dom (libxml-parse-html-region (point-min) (point-max))))
      (erase-buffer)
      (shr-insert-document dom)
      (goto-char (point-min))))

  (setq mu4e-html2text-command 'my-render-html-message
        mu4e-view-prefer-html t
        message-send-mail-function 'smtpmail-send-it
        smtpmail-stream-type 'starttls
        smtpmail-starttls-credentials '(("exchange.rose-hulman.edu" 587 nil nil))
        smtpmail-default-smtp-server "exchange.rose-hulman.edu"
        smtpmail-smtp-server "exchange.rose-hulman.edu"
        smtpmail-smtp-service 587
        smtpmail-debug-info t)
#+END_SRC
*** [[http://orgmode.org/][org-mode]]
:PROPERTIES:
:ORDERED:  t
:END:
Built into Emacs by default, but I need to configure some of it, especially how the agenda works.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-agenda-include-diary t)
  (setq org-agenda-start-on-weekday nil)
  (setq org-ellipsis "…")
  (setq org-src-fontify-natively t)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
  (add-hook 'org-mode-hook 'org-preview-latex-fragment)
  (add-hook 'org-cdlatex-mode-hook (lambda () (diminish 'org-cdlatex-mode)))
  (add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
  (add-hook 'org-mode-hook (lambda () (local-set-key (kbd "C-c C-x M-l") (kbd "C-u C-u C-c C-x C-l"))))

  (global-set-key (kbd "C-c a") 'org-agenda)

  (setq org-agenda-files (list "~/planner.org"))
#+END_SRC
*** [[https://github.com/dpsutton/resize-window][resize-window]]
Creates a new special mode where you can quickly resize any window using n-p-f-b. Makes it a lot easier to readjust things.

#+BEGIN_SRC emacs-lisp
  (req-package resize-window
    :init
    (global-set-key (kbd "C-S-r") 'resize-window))
#+END_SRC
*** [[https://github.com/Fuco1/smartparens][smartparens]]
Autobalances your parentheses as you type them. Great for Lisp programming.

#+BEGIN_SRC emacs-lisp
  (req-package smartparens
    :init
    (add-hook 'prog-mode-hook '(lambda ()
                                 (smartparens-mode 1))))
#+END_SRC
*** [[https://github.com/dimitri/switch-window][switch-window]]
Makes life so much easier when you have multiple windows open. Just hit one keyboard shortcut, press the number screen you want,
and you're there.

#+BEGIN_SRC emacs-lisp
  (req-package switch-window
    (global-set-key (kbd "s-o") 'switch-window))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]]
Shows a visual representation of your undo history as an easily navigable tree.

#+BEGIN_SRC emacs-lisp
  (req-package undo-tree
    :diminish undo-tree-mode)
#+END_SRC
*** [[https://github.com/capitaomorte/yasnippet][yasnippet]]
The basically necessary snippet package. Allows you to use little snippets that expand out to save a lot of typing.
I have yasnippet to load only when opening this session's first programming file, since it takes quite a while to load on
start up.

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :diminish yas-minor-mode
    :config
    (defvar yas-loaded 0)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'prog-mode-hook
              '(lambda ()
                 (when (= yas-loaded 1)
                       (setq yas-loaded 1)
                       (yas-reload-all)))))
#+END_SRC
** Visuals
*** [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]]
This makes programming files so much prettier and colorful, as it extrapolates colors from your current theme and color codes
all of your defined variables accordingly. This makes it easier to see where things are being used as well as a good syntax
checker to show that you spelled the variable correctly.

#+BEGIN_SRC emacs-lisp
  (req-package color-identifiers-mode
    :diminish color-identifiers-mode
    :config
    (global-color-identifiers-mode))
#+END_SRC
*** [[https://github.com/lunaryorn/fancy-battery.el][fancy-battery]]
Shows the current battery level as colored text in the mode line. Really nice since I start Emacs full screen and can't see
the OS's battery display.

#+BEGIN_SRC emacs-lisp
  (req-package fancy-battery)
#+END_SRC
*** [[https://github.com/oneKelvinSmith/monokai-emacs][monokai-theme]]
My personal theme of choice. I'm currently trying darkokai, we'll see if it sticks.

#+BEGIN_SRC emacs-lisp
  (req-package monokai-theme
    :disabled t
    :require fic-mode
    :init
    (load-theme 'monokai))
#+END_SRC
*** [[https://github.com/sjrmanning/darkokai][darkokai]]
I'm just trying this for now, but it seems nice.
The extra line is to keep the modeline small and not stupid looking.

#+BEGIN_SRC emacs-lisp
  (req-package darkokai-theme
    :require fic-mode
    :config
    (setq darkokai-mode-line-padding 1)
    (load-theme 'darkokai t))
#+END_SRC
*** [[http://elpa.gnu.org/packages/nlinum.html][nlinum]]
Like linum mode, but much, /much/, _much_ more efficient.

#+BEGIN_SRC emacs-lisp
    (req-package nlinum-mode
      :config
      (add-hook 'prog-mode-hook 'nlinum-mode))
#+END_SRC
*** [[https://github.com/sabof/org-bullets][org-bullets]]
Turn org-mode bullets into fancy utf-8 symbols that make them look so much prettier. Sorry if your browser can't see some
of the beautiful symbols. Take my word for it, they're just fancy bullets.

#+BEGIN_SRC emacs-lisp
  (req-package org-bullets
    :init
    (setq org-bullets-bullet-list
          '("◉" "◎" "⚫" "○" "►" "◇"))
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/PrettySymbol][prettify-symbols-mode]]
Built into Emacs by default. This essentially changes a few keywords into pretty symbols, like changing lambda to λ in Lisp.

#+BEGIN_SRC emacs-lisp
  (req-package prettify-symbols-mode
    :init
    (global-prettify-symbols-mode 1))
#+END_SRC
*** [[https://github.com/milkypostman/powerline][powerline]]
Makes the mode line look better in my opinion.

#+BEGIN_SRC emacs-lisp
  (req-package powerline)
#+END_SRC
*** [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimeters]]
This package recolors parentheses, braces, and brackets in matching pairs. This makes programming so much eaier and prettier.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** [[https://github.com/Benaiah/seethru][seethru]]
Allows easy and quick changes to a frame's transparency. I can probably reverse engineer this to avoid the overhead of
the full package.

#+BEGIN_SRC emacs-lisp
  (req-package seethru
    :disabled t
    :init
    (seethru 90))
#+END_SRC
*** [[https://github.com/k-talo/volatile-highlights.el][volatile-highlights]]
Whenever you change a large block of text, like with an undo or a yank,
this temporarily highlights it to draw attention to it.

#+BEGIN_SRC emacs-lisp
  (req-package volatile-highlights
    :diminish volatile-highlights-mode
    :config
    (volatile-highlights-mode t))
#+END_SRC
* Bucket List
Things I'd like to fix/improve when I have the time and know-how.

** Cool Packages
- https://github.com/mrkkrp/modalka
  - very customizable modal editing that works with Emacs rather than overwriting it
- https://github.com/twada/coverlay.el
  - shows code coverage according to an lcov file
** Adjust More Bindings to Colemak
- make C-n/C-e be page down/up
- get avy-menu to use Colemak home row
** Java
- find a nice syntax checker
** Loadup Speed
- figure out why it takes at least 10 seconds to start up
** Clean Up Mode Line
- smart-mode-line?
- there are currently lots of things that are smooshed to the right side, I'd like to make it a little prettier
** Better IDE-style things?
- maybe [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][CEDET]] or irony?
** Move-To-Char
Reverse-engineer zzz-to-char to make a move to char, which would function the same,
just it wouldn't actually delete text, only move the cursor.
