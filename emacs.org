* Overview
This is my personal setup for Emacs. Most everything should work right out of
the box, but one may need to do some fanagling to get it to work the first time.

One thing to note is that I use the Colemak keyboard layout, which means some of
my keybindings may seem a little weird. I've thought of this and created a flag
called =flag-colemak= in init.el. If you want to use more QWERTY bindings, set
that to 0 instead of 1. These other bindings will be listed in [ ] next to the
defaults.

I also use the super key (s- ) in a few of my bindings. If you want to use them
as-is, you need to look into getting the key to work properly on your OS.
* General Settings
** File Aliases
#+BEGIN_SRC emacs-lisp
  (defvar file-aliases '())

  (defun quick-open-file (key)
    (interactive "c")
    (let ((filename (alist-get key file-aliases)))
      (when filename (find-file filename))))

  (defun add-quick-file (key filename)
    (setf (alist-get key file-aliases) filename))

  (add-quick-file ?e "~/.emacs.d/emacs.org")
  (add-quick-file ?p "~/org-files/planner.org")
  (add-quick-file ?n "~/org-files/notes.org")
  (add-quick-file ?c "~/org-files/classes.org")
  (add-quick-file ?l "~/financial/ledger")

  (global-set-key (kbd "s-n") 'quick-open-file)
#+END_SRC
** Clean Init
I don't like the splash-screen, and I don't need the tool bar, menu bar, or
scroll bar, so get rid of them.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC
** Tab Configuration
I use 4 space tabs, and (for my preferences) I use spaces.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4
                indent-tabs-mode nil)

#+END_SRC
** Whitespace Cleanup
It‚Äôs nice to remove all the extra whitespaces every time I save.

#+BEGIN_SRC emacs-lisp
  (defun whitespace-cleanup-on-save ()
    (add-hook 'after-save-hook 'whitespace-cleanup nil t))

  (add-hook 'prog-mode-hook 'whitespace-cleanup-on-save)
  (add-hook 'org-mode-hook 'whitespace-cleanup-on-save)
#+END_SRC
** Input Method
It's always a pain to input fancy unicode characters. I have char-menu to
alleviate some of this, but for less used characters, I use this to type
them with LaTeX style \ codes.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method 'TeX)
#+END_SRC
** Smooth Scrolling
I really don't like how Emacs scrolls by default, so this code implements smooth
scrolling.

#+BEGIN_SRC emacs-lisp
  (setq redisplay-dont-pause t ;;Smooth scrolling
        scroll-margin 3
        scroll-step 1
        scroll-conservatively 10000
        scroll-preserve-screen-position 1)
#+END_SRC
** Hide Make Buffers
I don't really like having a new window pop up to tell me what happened during a
make. This makes it so that the minibuffer tells you whether the compilation
succeeded or failed.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'display-buffer-alist
               '("*compilation*" . (display-buffer-no-window)))
#+END_SRC
** Set Default Browser To EWW
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'firefox)
#+END_SRC
** Overwrite Selected Text
Emacs usually deselects a region once you start typing, but I like it to delete
the selected text in that case.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC
** File Encoding
UTF-8 is amazing, so use that by default.

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC
** Lego Theme
My own creation, and definitely still a work in progress, but I can change
whatever I want to whenever I need to, so that's nice.

#+BEGIN_SRC emacs-lisp
  (load-theme 'lego t)
#+END_SRC
** Font
This is just the font I‚Äôm using.

#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist (cons '(font . "DejaVu Sans Mono-14")
                                  default-frame-alist))
#+END_SRC
** Stop That Infernal Beeping
I hate Emacs beeping whenever I do anything, and this fixes it‚Ä¶in a really
roundabout way. Basically I‚Äôm overriding the function that says to ‚Äúbeep‚Äù
with the no-op thunk.

#+BEGIN_SRC emacs-lisp
  (defun thunk ())
  (setq ring-bell-function 'thunk)
#+END_SRC
** Org Directory
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/org-files/")
#+END_SRC
** Async Shell Buffer
#+BEGIN_SRC emacs-lisp
  (setq async-shell-command-buffer 'new-buffer)
#+END_SRC
* Packages
** Control
*** [[https://github.com/abo-abo/avy][avy]]
A lovely package that allows you to quickly jump to wherever you want to go
practically instantly.
- keybinds:
  + M-s - use avy with one word
  + M-l - use avy to go to a line
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    (("M-s" . avy-goto-word-1)
     ("M-S-s" . avy-goto-char-2)
     ("M-l" . avy-goto-line)))
#+END_SRC
*** [[https://github.com/joodland/bm][bm]]
An extremely simple yet really helpful package that allows you to mark multiple
different positions in a file and cycle through them with ease. Really useful
when you need to go looking for something but want to save your spot, or if you
keep bouncing between a few spots in a file.
#+BEGIN_SRC emacs-lisp
  (use-package bm ;;make bookmarks and cycle through them
    :ensure t
    :config
    (global-set-key (kbd "M-T") 'bm-toggle)
    (global-set-key (kbd "M-N") 'bm-next)
    (global-set-key (kbd "M-P") 'bm-previous))
#+END_SRC
*** [[https://github.com/magnars/expand-region.el][expand-region]]
Gives the ability to quickly create and expand a region to fill some kind of
boundary, like parentheses or quotes. This gives Emacs something like the
functionality of Vim with its "change-in" commands.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "M-i") 'er/expand-region))
#+END_SRC
*** [[https://github.com/victorhge/iedit][iedit]]
Allows you to edit all instances of the word under the cursor at the same time,
which can be quite the timesaver when refactoring things. Alongside narrowing
buffers, this can be super powerful. Currently bound to =C-;=.

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t)
#+END_SRC
*** [[https://github.com/abo-abo/swiper][ivy]]
Fuzzy searching.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :config (ivy-mode 1))
#+END_SRC
*** [[https://github.com/abo-abo/hydra][hydra]]
This lovely package allows for improved use of chaining similar commands.
I'll be trying to use it to wean myself off of some of the features
of evil-mode, but I'm sure I'll keep both installed for a while.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t
    :config
    (defhydra hydra-motion (:body-pre (next-line))
      "motion"
      ("h" backward-char "‚Üê")
      ("n" next-line "‚Üì")
      ("e" previous-line "‚Üë")
      ("i" forward-char "‚Üí")
      ("g" nil "√ó"))
    (global-set-key (kbd "C-n") #'hydra-motion/next-line))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/KeyChord][key-chord]]
Allows the ability to define different key chords, key combinations
that trigger an action when pressed in quick succession.

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :config
    (setq key-chord-one-key-delay 0.2)
    (setq key-chord-two-key-delay 0.2)
    (key-chord-define c-mode-map ".." "->")
    (key-chord-define c++-mode-map ".." "->")
    (key-chord-define global-map "-." "‚Üí")
    (key-chord-define-global ",-" "‚Üê")
    (key-chord-define-global "--" "_")
    (key-chord-define-global "vf" 'find-file)
    (key-chord-define-global "vu" 'undo)
    (key-chord-define-global "vs" 'save-buffer)
    (key-chord-define-global "vl" 'ispell-buffer)
    (key-chord-define-global "VL" 'endless/ispell-word-then-abbrev)
    (key-chord-mode 1))
#+END_SRC
*** [[https://github.com/noctuid/link-hint.el][link-hint]]
I really don‚Äôt like manually moving the cursor around just to select a link, so
I just use this to jump straight to links when in things like EWW.

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :ensure t
    :bind ("M-L" . link-hint-open-link))
#+END_SRC
*** [[https://github.com/itome/smart-backspace][smart-backspace]]
Deletes back a line to matching indentation.

#+BEGIN_SRC emacs-lisp
  (use-package smart-backspace
    :ensure t
    :config
    (global-set-key [C-backspace] 'smart-backspace))
#+END_SRC
*** [[http://elpa.gnu.org/packages/smart-yank.html][smart-yank]]
Makes yanking a little smarter. For one thing, when doing a yank-pop, it moves
the cut that you've popped to the top of the ring to make it easier the next
time, while it also resets the stack position upon any command rather than only
on kills.

#+BEGIN_SRC emacs-lisp
  (use-package smart-yank
    :ensure t
    :config
    (smart-yank-mode 1))
#+END_SRC
*** [[https://github.com/abo-abo/swiper][swiper]]
This basically extends ivy-mode to provide a comprehensive overview of whatever
you‚Äôre searching for.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :config (global-set-key (kbd "C-s") 'swiper))
#+END_SRC
*** [[https://github.com/mrkkrp/zzz-to-char][zzz-to-char]]
Visually kill a part of a line, forward or backward, to a given character.
This in some ways shoots Vim's kill-to command out of the water, simply
because of how easy it is to go to a specific instance of a character with
an avy backend.

#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind
    (("M-z" . zzz-up-to-char)
     ("M-S-z" . zzz-to-char)))
#+END_SRC
** Programming
*** [[https://www.emacswiki.org/emacs/CcMode][cc-mode]]
Built into Emacs. I'm just putting this here to establish a few start up hooks.
I have individual setups for each C-type mode, just so that they actually work.

#+BEGIN_SRC emacs-lisp
  (setq-default c-basic-offset 4)
  (setq-default c++-basic-offset 4)

  (defun add-ac-sources ()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (add-hook 'cc-mode-common-hook 'add-ac-sources)
  (add-hook 'c-mode-common-hook 'add-ac-sources)
  (add-hook 'c++-mode-common-hook 'add-ac-sources)

  (add-hook 'cc-mode-hook 'semantic-mode)
  (add-hook 'c-mode-hook 'semantic-mode)
  (add-hook 'c++-mode-hook 'semantic-mode)
#+END_SRC
*** [[https://github.com/jscheid/dtrt-indent][dtrt-indent]]
This is an especially useful package when editing code that somebody else wrote,
as it automatically detects what the indentation size is and sets yours to
match.

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :ensure t)
#+END_SRC
*** [[https://github.com/lewang/fic-mode][fic-mode]]
Another tiny yet remarkably helpful package that just highlights keywords like
TODO or FIXME in comments. It is currently turned on in any prog-mode. Someday I
should just write something like this myself, both for experience and so that
this doesn't keep slowing down my boot up time.

#+BEGIN_SRC emacs-lisp
  (use-package fic-mode
    :ensure t
    :diminish fic-mode
    :config
    (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC
*** [[https://github.com/flycheck/flycheck][flycheck]]
A magic little syntax checker for various languages like C. It sets a
compiler flag for gnu11, since my computer doesn't compile =for= loops
and the like by default for some reason. Triggered in any prog-mode.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (flycheck-set-checker-executable 'c/c++-gcc "/usr/bin/gcc")
    (setq flycheck-gcc-args "-std=c++11")

    (add-hook 'prog-mode-hook 'flycheck-mode))
#+END_SRC
*** gdb
I prefer the many windows mode of gdb.

#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t)
#+END_SRC
*** [[https://github.com/leoliu/ggtags][ggtags]]
C/C++ program tagging. This allows one to easily jump around a program to
definitions and usages of variables and functions.
- keybinds:
  + M-g M-g - go to either the definition or usage of the symbol at point
  + M-g r - return to the last point jumped from

#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :ensure t
    :diminish ggtags-mode
    :config
    (add-hook 'c-mode-hook #'ggtags-mode)
    (add-hook 'c++-mode-hook #'ggtags-mode)
    (add-hook 'cc-mode-hook #'ggtags-mode)
    (add-hook 'java-mode-hook #'ggtags-mode)
    (add-hook 'asm-mode-hook #'ggtags-mode)
    (define-key ggtags-mode-map (kbd "M-g M-g") #'ggtags-find-tag-dwim)
    (define-key ggtags-mode-map (kbd "M-g r") #'ggtags-prev-mark))
#+END_SRC
*** geiser
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :config
    (setq geiser-default-implementation 'chez))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/HideShow][hs]]
A very effective code folding package that is started in any prog-mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'hs-minor-mode-hook '(lambda () (diminish 'hs-minor-mode)))
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (global-set-key (kbd "C-c C-f") 'hs-toggle-hiding)
#+END_SRC
*** lisp-mode
Built into Emacs (or more specifically, builds Emacs) by default. Right now I'm
just specifying .stumpwmrc should be in lisp mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '(".stumpwmrc" . lisp-mode))
#+END_SRC
*** scheme-mode
A lot of these settings are from the default config for my CSSE304 class.
I am using petite chez as my interpereter, as it is required for the class.

#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.ss" . scheme-mode) auto-mode-alist))
  (setq scheme-program-name "petite")

  (put 'eval-when 'scheme-indent-function 1)
  (put 'set! 'scheme-indent-function 1)
  (put 'when 'scheme-indent-function 1)
  (put 'unless 'scheme-indent-function 1)
  (put 'record-case 'scheme-indent-function 1)
  (put 'c-record-case 'scheme-indent-function 1)
  (put 'variant-case 'scheme-indent-function 1)
  (put 'parameterize 'scheme-indent-function 1)
  (put 'call-with-values 'scheme-indent-function 1)
  (put 'extend-syntax 'scheme-indent-function 1)
  (put 'with 'scheme-indent-function 1)
  (put 'let 'scheme-indent-function 1)
  (put 'let-syntax 'scheme-indent-function 1)
  (put 'letrec-syntax 'scheme-indent-function 1)
  (put 'with-syntax 'scheme-indent-function 1)
  (put 'syntax-case 'scheme-indent-function 2)
  (put 'syntax 'scheme-indent-function 1)
  (put 'syntax-rules 'scheme-indent-function 1)
  (put 'foreign-procedure 'scheme-indent-function 1)
  (put 'set-top-level-value! 'scheme-indent-function 1)
  (put 'make-parameter 'scheme-indent-function 1)
  (put 'decompose 'scheme-indent-function 2)
  (put 'mvlet 'scheme-indent-function 1)
  (put 'mvlet* 'scheme-indent-function 1)
  (put 'state-case 'scheme-indent-function 1)
  (put 'foreach 'scheme-indent-function 1)
  (put 'vector-foreach 'scheme-indent-function 1)
  (put 'assert 'scheme-indent-function 1)
  (put 'fold-list 'scheme-indent-function 2)
  (put 'fold-vector 'scheme-indent-function 2)
  (put 'fold-count 'scheme-indent-function 2)
  (put 'on-error 'scheme-indent-function 1)
#+END_SRC
** Usability
*** [[https://github.com/jgkamat/alda-mode][alda-mode]]
Ties into the musical programming language alda. It's just kind of fun to mess
around in.

#+BEGIN_SRC emacs-lisp
  (use-package alda-mode
    :ensure t
    :config
    (setq set-alda-binary-location "/usr/local/bin/alda"))
#+END_SRC
*** [[https://github.com/cdominik/cdlatex][cdlatex]]
Provides quick shortcuts for lots of long latex symbols. For example, `a turns
into =\alpha=.

#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :ensure t
    :diminish cdlatex-mode)
#+END_SRC
*** [[https://github.com/mrkkrp/char-menu][char-menu]]
Allows you to build your own tree of special characters that can be accessed via
an avy-menu...menu.

#+BEGIN_SRC emacs-lisp
  (use-package char-menu
    :ensure t
    :init
    (setq char-menu '("‚Äô" "‚Äò‚Äô" "‚Äú‚Äù" "‚Ä¶" "‚åä‚åã" "‚ãÄ" "‚ãÅ" "‚àö"
                      ("script" "‚Ñõ" "‚Ñí")
                      ("emoji" "üòè" "üòâ" "üò≠" "üò¶" "üòä" "ü§î" "üò¢")))
    (global-set-key (kbd "M-o") 'char-menu))
#+END_SRC
*** [[https://github.com/company-mode/company-mode][company]]
Autocomplete that goes with just about everything. This is currently enabled
globally.

#+BEGIN_SRC emacs-lisp
  (use-package company ;;TODO Speed up
    :ensure t
    :diminish company-mode
    :config
    (global-company-mode))
#+END_SRC
*** dad-joke
üòè

#+BEGIN_SRC emacs-lisp
  (use-package dad-joke
    :ensure t
    :bind (("s-d" . dad-joke)))
#+END_SRC
*** desktop-environment
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :ensure t
    :init
    (desktop-environment-mode))
#+END_SRC
*** dired
#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t
        dired-recursive-copies 'top
        dired-recursive-deletes 'top
        dired-listing-switches "-alh")
#+END_SRC
*** exwm
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :init

    (defun launch-exwm (arg)
      (when (equal arg "exwm")
        (require 'exwm-config)
        (exwm-config-default)))

    (add-to-list 'command-switch-alist '("exwm" . launch-exwm)))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/FlySpell][flyspell]]
Built into Emacs by default. I only take this opportunity to set a quick
keybind for both that and visual-line-mode (also built in). If I care about
spelling, I also probably want lines to wrap properly.

#+BEGIN_SRC emacs-lisp
  (defun start-flyspell-and-visual ()
    "Call both function `flyspell' and function `visual-line-mode'."
    (interactive)
    (flyspell-mode t)
    (visual-line-mode))

  (use-package flyspell
    :ensure t
    :init
    (global-set-key (kbd "C-x l") 'start-flyspell-and-visual)
    (add-hook 'org-mode-hook 'flyspell-mode))
#+END_SRC
*** [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]
When editing a file under version control, this shows little markers indicating
if a line has been added, modified, or deleted.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
    :ensure t
    :diminish git-gutter-mode
    :init
    (global-git-gutter-mode 1))
#+END_SRC
*** [[https://github.com/pidu/git-timemachine][git-timemachine]]
Allows you to quickly go through the git history of a file.

p = previous
n = next
w = view hash
W = copy hash
q = quit

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC
*** ledger-mode
Useful for keeping a budget and tracking expenses.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :bind (("s-r" . ledger-mode-clean-buffer))
    :custom (ledger-post-auto-adjust-amounts t)
    :init
    (add-hook 'ledger-mode-hook (lambda () (company-mode 0)))
    (add-to-list 'auto-mode-alist '("ledger$" . ledger-mode)))
#+END_SRC
*** [[https://github.com/wasamasa/nov.el][nov.el]]
Honestly the only good way I've found to read =EPUB='s in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :config
    (push '("\\.epub\\'" . nov-mode) auto-mode-alist))
#+END_SRC
*** [[https://github.com/magit/magit][magit]]
The best way to use git with Emacs. Period.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :init
    (setq magit-restore-window-configuration t)
    (setq magit-completing-read-function 'ivy-completing-read)
    (global-set-key (kbd "s-g") 'magit-status)
    (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))
#+END_SRC
*** [[https://github.com/danielma/magit-org-todos.el][magit-org-todos]]
Nicely handles =todo.org= files in the root of a =git= repository.

#+BEGIN_SRC emacs-lisp
  (use-package magit-org-todos
    :ensure t
    :config (magit-org-todos-autoinsert))
#+END_SRC
*** mu4e
The various =setq='s are all just personal settings for dealing with my specific
email setup. The interesting one, the html2text-command, is stolen from
[[http://emacs.stackexchange.com/questions/3051/how-can-i-use-eww-as-a-renderer-for-mu4e][link]]. It basically just renders any html email so it doesn‚Äôt look stupid.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :bind (("s-m" . mu4e))
    :config
    (require 'mu4e-contrib)
    (require 'org-mu4e)

    (setq org-mu4e-convert-to-html t)

    (defun compose-org-message ()
      (interactive)
      (org~mu4e-mime-switch-headers-or-body)
      ;; We need these options to make the HTML look non-stupid
      (insert "#+OPTIONS: tex:imagemagick\n#+OPTIONS: toc:0\n\n"))

    (bind-key "C-c o" 'compose-org-message mu4e-compose-mode-map)
    (setq mu4e-maildir "~/Maildir"
          mu4e-sent-folder "/[Gmail].Sent Mail"
          mu4e-drafts-folder "/[Gmail].Drafts"
          mu4e-refile-folder "/[Gmail].All Mail"
          mu4e-trash-folder "/[Gmail].Trash"
          mu4e-get-mail-command "offlineimap"
          mu4e-update-interval 300
          mu4e-compose-signature (concat "Lewis Kelley\n"
                                         "\n"
                                         "CSSE Sophomore Resident Tutor\n"
                                         "In-Room (Lakeside 118): Sun/Thu 6:30-8:00\n"
                                         "Percopo Classroom: Tue 8:00-11:00")
          mu4e-view-prefer-html t
          message-send-mail-function 'smtpmail-send-it
          starttls-use-gnutls t
          smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
          smtpmail-auth-credentials '(("smtp.gmail.com" 587 "rosetintedbilliken@gmail.com" nil))
          smtpmail-default-smtp-server "smtp.gmail.com"
          smtpmail-smtp-server "smtp.gmail.com"
          smtpmail-smtp-service 587
          user-mail-address "rosetintedbilliken@gmail.com"
          user-full-name "Lewis Kelley"
          mu4e-maildir-shortcuts '(("/INBOX" . ?i)
                                   ("/[Gmail].Sent Mail" . ?s)
                                   ("/[Gmail].Drafts" . ?d)
                                   ("/[Gmail].All Mail" . ?a)))

    (add-to-list 'mu4e-view-actions
                 '("xViewXWidget" . mu4e-action-view-with-xwidget) t)

    (setq mu4e-compose-complete-addresses nil)

    ;; Notify the desktop
    (add-hook 'mu4e-index-updated-hook
              (lambda ()
                (let ((unread (shell-command "new_emails")))
                  (when (> unread 0)
                    (shell-command (concat "notify-send Mail \"Unread messages: "
                                           unread
                                           "\""))))))

    ;; I like being safe
    (add-hook 'message-send-hook
              (lambda ()
                (unless (yes-or-no-p "Sure you want to send this? ")
                  (signal 'quit nil)))))
#+END_SRC
*** [[https://github.com/Kungsgeten/org-brain][org-brain]]
#+BEGIN_SRC emacs-lisp
  (use-package org-brain
    :ensure t
    :config
    (defun website-resource-icon (link)
      "Return an icon representing a given webpage."
      (cond ((string-match "wikipedia\\.org" link)
             (all-the-icons-faicon "wikipedia-w"))
            ((string-match "github\\.com" link)
             (all-the-icons-octicon "mark-github"))
            ((string-match "youtube\\.com" link)
             (all-the-icons-faicon "youtube"))
            (t
             (all-the-icons-faicon "globe"))))

    (defun org-brain-insert-resource-icon (link)
      "Insert an icon, based on content of org-mode LINK."
      (insert (format "%s "
                      (cond ((string-prefix-p "http" link)
                             (website-resource-icon link))
                            ((string-prefix-p "brain:" link)
                             (all-the-icons-fileicon "brain"))
                            (t
                             (all-the-icons-icon-for-file link))))))

    (add-hook 'org-brain-after-resource-button-functions
              #'org-brain-insert-resource-icon)
    :custom
    (org-id-track-globally t)
    (org-id-locations-file "~/.emacs.d/.org-id-locations")
    (org-brain-visualize-default-choices 'all)
    (org-brain-title-max-length 12)
    :bind
    (("C-c b" . org-brain-visualize)
     :map org-brain-visualize-mode-map
     ("L" . link-hint-open-link))
    :hook
    (org-brain-after-visualize . aa2u-buffer))
#+END_SRC
*** [[http://orgmode.org/][org-mode]]
**** General Org
Built into Emacs by default, but I need to configure some of it, especially how
the agenda works.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-use-speed-commands t)
  (setq org-ellipsis "‚Ä¶")
  (setq org-src-fontify-natively t)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
  (add-hook 'org-cdlatex-mode-hook (lambda () (diminish 'org-cdlatex-mode)))
  (add-hook 'org-indent-mode-hook (lambda () (diminish 'org-indent-mode)))
  (add-hook 'org-mode-hook (lambda ()
                             (local-set-key (kbd "C-c C-x M-l")
                                            (kbd "C-u C-u C-c C-x C-l"))))

  (setq org-columns-default-format
        "%40ITEM(Task) {:} %CLOCKSUM")

  (set-face-attribute 'org-todo nil
                      ':box '(:line-width 3 :color "Red1" :style released-button))
  (set-face-attribute 'org-done nil
                      ':box '(:line-width 3 :color "PaleGreen" :style pressed-button))

  (setq org-export-with-toc nil
        org-export-with-section-numbers nil
        org-latex-image-default-width nil)

  ;; Change the size of rendered LaTeX fragments
  (plist-put org-format-latex-options :scale 2.0)
#+END_SRC
**** Agenda
Some basic settings.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-include-diary t
        org-agenda-start-on-weekday nil
        org-agenda-files (list (concat org-directory "classes.org")
                               (concat org-directory "planner.org")
                               (concat org-directory "calendar.org")))

  (global-set-key (kbd "C-c a") 'org-agenda)
  (add-hook 'org-agenda-mode-hook 'delete-other-windows)
#+END_SRC
#+END_SRC
**** Org Babel
For some reason, ox.el isn‚Äôt loading properly. That‚Äôs the file that tells org
how to do that cool LaTeX rendering, so I definitely want that on.

#+BEGIN_SRC emacs-lisp
  (require 'ox)
#+END_SRC

You‚Äôll probably want to change the location of the plantuml jar file, but who
knows, it might be right! I also ask org not to bug me about evaluating code
blocks in files; it‚Äôs just not worth the hassle, especially when I‚Äôm exporting a
large notes file.

#+BEGIN_SRC emacs-lisp
  (require 'ob)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((plantuml . t)
     (C . t)
     (java . t)
     (octave . t)
     (dot . t)
     (lisp . t)
     (python . t)
     (scheme . t)))

  (setq org-confirm-babel-evaluate nil)
  (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
  (setq org-plantuml-jar-path "/usr/share/plantuml/lib/plantuml.jar")
#+END_SRC

**** Clocking and Capturing
I like using Org‚Äôs clocking function. The number of times I clock in and out
makes the global keybindings very useful.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-x C-x") 'org-clock-in-last)
  (global-set-key (kbd "C-c C-x C-o") 'org-clock-out)
  (global-set-key (kbd "C-c C-x C-j") 'org-clock-goto)

  (setq org-time-stamp-rounding-minutes '(1 1))
  (setq org-clock-out-remove-zero-time-clocks t)
#+END_SRC

Capturing is fun.

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat org-directory "planner.org"))
  (define-key global-map (kbd "C-c c") 'org-capture)

  (let ((refile-files (mapcar (lambda (file) (concat org-directory file))
                              (list "classes.org"
                                    "planner.org"
                                    "tutoring.org"
                                    "wishlist.org"))))
    (setq org-refile-targets (list (cons refile-files '(:level . 1)))))

  (setq org-capture-templates '())
#+END_SRC

Capture templates for my planner. I should probably add more categories‚Ä¶

#+BEGIN_SRC emacs-lisp
  (let ((planner-file (concat org-directory "planner.org")))
    (push `("e" "Entertainment Event" entry
            (file ,planner-file)
            ,(concat "* %^{Title} :fun:\n"
                     "%^T\n"
                     "%a\n"
                     "%i\n"
                     "%?"))
          org-capture-templates)
    (push `("r" "Random Event" entry
            (file ,planner-file)
            ,(concat "* %^{Title}\n"
                     "%^T\n"
                     "%a\n"
                     "%i\n"
                     "%?"))
          org-capture-templates))
#+END_SRC

This lets me try to track the time of people I'm tutoring a little
more efficiently. It doesn't work too well when multiple people come
it at once, though‚Ä¶

#+BEGIN_SRC emacs-lisp
  (push `("t" "Tutoring" entry
            (file ,(concat org-directory "tutoring.org"))
            ,(concat "* %^{Name}\n"
                     ":PROPERTIES:\n"
                     ":CLASS:     %^{Class}\n"
                     ":PROFESSOR: %^{Professor}\n"
                     ":PROBLEM:   %^{Problem Description}\n"
                     ":DATE:      %t\n"
                     ":TIME:      %^{Time}\n"
                     ":END:"))
          org-capture-templates)
#+END_SRC

Various different categories of things I'd like to read/watch/play/do
someday.

#+BEGIN_SRC emacs-lisp
  (let ((wishlist-file (concat org-directory "wishlist.org"))
        (basic-template "* %^{Title}\n%?"))
    (push `("b" "Book" entry
            (file+headline ,wishlist-file "Books")
            ,basic-template)
          org-capture-templates)
    (push `("g" "Video Game" entry
            (file+headline ,wishlist-file "Video Games")
            ,basic-template)
          org-capture-templates)
    (push `("G" "Board Game" entry
            (file+headline ,wishlist-file "Board Games")
            ,basic-template)
          org-capture-templates)
    (push `("m" "Movie" entry
            (file+headline ,wishlist-file "Movies")
            ,basic-template)
          org-capture-templates))
#+END_SRC

For easy log entries into my journal.

#+BEGIN_SRC emacs-lisp
  (push `("D"
            "Chronicle Entry"
            entry
            (file+datetree+prompt ,(concat org-directory "chronicle.org"))
            "* %^{Title}\n%?")
          org-capture-templates)
#+END_SRC
*** octave-mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m" . octave-mode))
#+END_SRC
*** [[https://github.com/Malabarba/paradox/][paradox]]
Allows for asynchronous installation of packages.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :ensure t
    :bind ("s-p" . paradox-list-packages))
#+END_SRC
*** [[https://github.com/skuro/plantuml-mode][plantuml-mode]]
PlantUML is a nice way of making UML diagrams without futzing with drag and drop
interfaces (i.e. touching the mouse). This requires you to point to where the
jar file is, so you may have to change that.

#+BEGIN_SRC emacs-lisp
  (use-package plantuml-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))
    (add-to-list 'auto-mode-alist '("\\.puml\\'" . plantuml-mode))
    (setq plantuml-jar-path "/usr/share/plantuml/lib/plantuml.jar"))
#+END_SRC
*** [[https://github.com/dpsutton/resize-window][resize-window]]
Creates a new special mode where you can quickly resize any window using n-p-f-b. Makes it a lot easier to readjust things.

#+BEGIN_SRC emacs-lisp
  (use-package resize-window
    :ensure t
    :init
    (global-set-key (kbd "C-S-r") 'resize-window))
#+END_SRC
*** [[https://github.com/Fuco1/smartparens][smartparens]]
Autobalances your parentheses as you type them. Great for Lisp programming.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :init
    (add-hook 'prog-mode-hook '(lambda ()
                                 (smartparens-mode 1)))
    :config
    (defhydra hydra-smartparens (global-map "C-c s"
                                            :hint nil)
      "
  ^Motion^           ^Movement^       ^Actions
  ^^^^^^-------------------------------------------
  _n_: down          _s_: slurp       _i_: inner
  _p_: up            _S_: barf        _k_: kill
  _f_: forward       _c_: split       _w_: rewrap
  _b_: back          _u_: splice
  _F_: next          _r_: raise       _g_: quit
  _B_: previous      _t_: transpose
  _a_: beginning
  _b_: end
  "
      ("n" sp-down-sexp)
      ("p" sp-backward-up-sexp)
      ("f" sp-forward-sexp)
      ("F" sp-next-sexp)
      ("b" sp-backward-sexp)
      ("B" sp-previous-sexp)
      ("a" sp-beginning-of-sexp)
      ("e" sp-end-of-sexp)

      ("s" sp-slurp-hybrid-sexp)
      ("S" sp-forward-barf-sexp)
      ("c" sp-split-sexp)
      ("u" sp-splice-sexp)
      ("r" sp-raise-sexp)
      ("t" sp-transpose-sexp)

      ("i" sp-change-inner)
      ("k" sp-kill-sexp)
      ("w" sp-rewrap-sexp)

      ("g" nil)))
#+END_SRC
*** [[https://github.com/dimitri/switch-window][switch-window]]
Makes life so much easier when you have multiple windows open. Just hit one keyboard shortcut, press the number screen you want,
and you're there.

#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (global-set-key (kbd "s-o") 'switch-window))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/UndoTree][undo-tree]]
Shows a visual representation of your undo history as an easily navigable tree.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config (global-undo-tree-mode))
#+END_SRC
*** [[https://github.com/bcbcarl/emacs-wttrin][wttrin]]
A nice forecast program with some nice ASCII art for the clouds. Now I can check what the weather is like without
even looking out a window!

#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :ensure t
    :config
    (setq wttrin-default-cities '("St. Louis" "Terre Haute"))
    (setq wttrin-default-accept-language '("Accept Language" . "en-US"))
    (global-set-key (kbd "s-f") 'wttrin))
#+END_SRC
*** [[https://github.com/capitaomorte/yasnippet][yasnippet]]
The basically necessary snippet package. Allows you to use little snippets that expand out to save a lot of typing.
I have yasnippet to load only when opening this session's first programming file, since it takes quite a while to load on
start up.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (defvar yas-loaded 0)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'prog-mode-hook
              '(lambda ()
                 (when (= yas-loaded 1)
                       (setq yas-loaded 1)
                       (yas-reload-all)))))
#+END_SRC
** Visuals
*** [[http://www.gnuvola.org/software/aa2u/][ascii-art-to-unicode]]
Mostly used for =org-brain=.

#+BEGIN_SRC emacs-lisp
    (use-package ascii-art-to-unicode
      :ensure t
      :config
      (defun aa2u-buffer ()
        (interactive)
        (aa2u (point-min) (point-max))))
#+END_SRC
*** [[https://github.com/domtronn/all-the-icons.el][all-the-icons]]
Shows fancy looking icons on file names (looks really pretty).

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+END_SRC
*** [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers-mode]]
This makes programming files so much prettier and colorful, as it extrapolates colors from your current theme and color codes
all of your defined variables accordingly. This makes it easier to see where things are being used as well as a good syntax
checker to show that you spelled the variable correctly.

#+BEGIN_SRC emacs-lisp
  (use-package color-identifiers-mode
    :ensure t
    :diminish color-identifiers-mode
    :config
    (global-color-identifiers-mode))
#+END_SRC
*** [[https://github.com/jordonbiondo/column-enforce-mode][column-enforce-mode]]
Highlights texts that goes beyond a certain column. Very nice for coding.

#+BEGIN_SRC emacs-lisp
  (use-package column-enforce-mode
    :ensure t
    :config
    (add-hook 'c-mode-hook 'column-enforce-mode))
#+END_SRC
*** [[http://elpa.gnu.org/packages/nlinum.html][nlinum]]
Like linum mode, but much, /much/, _much_ more efficient.

#+BEGIN_SRC emacs-lisp
  (use-package nlinum
    :ensure t)
#+END_SRC
*** [[https://github.com/sabof/org-bullets][org-bullets]]
Turn org-mode bullets into fancy utf-8 symbols that make them look so much prettier. Sorry if your browser can't see some
of the beautiful symbols. Take my word for it, they're just fancy bullets.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :init
    (setq org-bullets-bullet-list
          '("‚óâ" "‚óé" "‚ö´" "‚óã" "‚ñ∫" "‚óá"))
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/PrettySymbol][prettify-symbols-mode]]
Built into Emacs by default. This essentially changes a few keywords into pretty symbols, like changing lambda to Œª in Lisp.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC
*** [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimeters]]
This package recolors parentheses, braces, and brackets in matching
pairs. This makes programming so much easier and prettier.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** [[https://github.com/zk-phi/sky-color-clock][sky-color-clock]]
#+BEGIN_SRC emacs-lisp
  (require 'sky-color-clock)
  (sky-color-clock-initialize 39.4)
#+END_SRC
*** [[https://github.com/k-talo/volatile-highlights.el][volatile-highlights]]
Whenever you change a large block of text, like with an undo or a yank,
this temporarily highlights it to draw attention to it.

#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :ensure t
    :diminish volatile-highlights-mode
    :config
    (volatile-highlights-mode t))
#+END_SRC
* Custom Functions
** Modeline Customization
Just making my modeline fancy.
Note that this requires the package all-the-icons.
#+BEGIN_SRC emacs-lisp
  (defvar orig-mode-line mode-line-format)
  (defvar mode-line-font-height 1.0)

  (defun reset-modeline ()
    (interactive)
    (setq mode-line-format orig-mode-line))

  (defun custom-modeline-modified ()
    (let* ((config-alist
            '(("*" all-the-icons-faicon-family
               all-the-icons-faicon "chain-broken" :height 1.2 :v-adjust -0.0)
              ("-" all-the-icons-faicon-family
               all-the-icons-faicon "link" :height 1.2 :v-adjust -0.0)
              ("%" all-the-icons-octicon-family all-the-icons-octicon "lock"
               :height 1.2 :v-adjust 0.1)))
           (result (cdr (assoc (format-mode-line "%*") config-alist))))
      (propertize (apply (cadr result) (cddr result))
                  'face `(:family ,(funcall (car result))))))

  (defun custom-modeline-mode-icon ()
    (format " %s"
            (let* ((icon (all-the-icons-icon-for-buffer))
                   (is-string (stringp icon))
                   (height (if is-string 1.25 1.00)))
              (propertize
               (if is-string icon
                 (format "%s" major-mode))
               'help-echo (format "Major-mode: `%s`" major-mode)
               'face `(:foreground "dark olive green"
                                   :height
                                   ,mode-line-font-height
                                   :family
                                   ,(if is-string
                                        (all-the-icons-icon-family-for-buffer)
                                      "DejaVu Sans Mono"))))))

  (defun custom-modeline-region-info ()
    (when mark-active
      (let ((words (count-lines (region-beginning) (region-end)))
            (chars (count-words (region-end) (region-beginning))))
        (concat
         (propertize (format "   %s" (all-the-icons-octicon "pencil") words chars)
                     'face `(:family ,(all-the-icons-octicon-family))
                     'display '(raise -0.0))
         (propertize (format " (%s, %s)" words chars)
                     'face `(:height 0.9))))))

  (defun -custom-modeline-github-vc ()
    (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
      (concat
       (propertize (format " %s" (all-the-icons-alltheicon "git"))
                   'face `(:height 1.2 :family ,(all-the-icons-octicon-family))
                   'display '(raise -0.1))
       " ¬∑ "
       (propertize (format "%s" (all-the-icons-octicon "git-branch"))
                   'face `(:height 1.3 :family ,(all-the-icons-octicon-family))
                   'display '(raise -0.1))
       (propertize (format " %s" branch) 'face `(:height 0.9)))))

  (defun -custom-modeline-svn-vc ()
    (let ((revision (cadr (split-string vc-mode "-"))))
      (concat
       (propertize (format " %s" (all-the-icons-faicon "cloud"))
                   'face `(:height 1.2)
                   'display '(raise -0.1))
       (propertize (format " ¬∑ %s" revision) 'face `(:height 0.9)))))

  (defun custom-modeline-icon-vc ()
    (when vc-mode
      (cond
       ((string-match "Git[:-]" vc-mode) (-custom-modeline-github-vc))
       ((string-match "SVN-" vc-mode) (-custom-modeline-svn-vc))
       (t (format "%s" vc-mode)))))

  (defun modeline-align (left right)
    (let ((available-width (- (window-width) (length left) 3)))
      (format (format " %%s %%%ds " available-width) left right)))

  (defun customize-modeline ()
    (interactive)
    (setq-default mode-line-format
                  '(concat " %e"
                           (:eval
                            (modeline-align
                             (concat
                              (propertize (custom-modeline-modified)
                                          'face
                                          `(:foreground
                                            "pink"
                                            :height
                                            ,mode-line-font-height))
                              (propertize " %3I"
                                          'face
                                          `(:foreground
                                            "firebrick"
                                            :height
                                            ,mode-line-font-height))
                              (propertize " %z | "
                                          'face
                                          `(:height ,mode-line-font-height))
                              (propertize "%4l"
                                          'face
                                          `(:foreground
                                            "tomato"
                                            :height
                                            ,mode-line-font-height))
                              (propertize ":"
                                          'face
                                          `(:height
                                            ,mode-line-font-height))
                              (propertize "%2c"
                                          'face
                                          `(:foreground
                                            "gold"
                                            :height
                                            ,mode-line-font-height))
                              (propertize (format "%3d%%%%"
                                                  (/ (window-start)
                                                     0.01
                                                     (point-max)))
                                          'face
                                          `(:foreground
                                            "medium purple"
                                            :height
                                            ,mode-line-font-height))
                              (if (not (equal (marker-buffer org-clock-marker)
                                              nil))
                                  (concat " | "
                                          (org-clock-get-clock-string)))
                              (propertize " |"
                                          'face
                                          `(:height
                                            ,mode-line-font-height))
                              (custom-modeline-mode-icon)
                              " "
                              (propertize (buffer-name)
                                          'face
                                          `(:foreground
                                            "white"
                                            :height
                                            ,mode-line-font-height))
                              " |"
                              (let ((text (custom-modeline-icon-vc)))
                                (if text
                                    (concat
                                     (propertize text
                                                 'face
                                                 `(:foreground
                                                   "orange"
                                                   :height
                                                   ,mode-line-font-height))
                                     " |"))))
                             (sky-color-clock))))))
  (set-face-attribute 'org-mode-line-clock nil :inherit nil)
  (customize-modeline)
#+END_SRC
** Clean Buffer
#+BEGIN_SRC emacs-lisp
  (defun clean-buffer ()
    "Reindent the whole buffer."
    (interactive)
    (indent-region (point-min) (point-max)))
#+END_SRC
** Hex Coloring
Changes the font color of colors to easily determine what they are.
Taken from http://ergoemacs.org/emacs/elisp_eval_lisp_code.html

#+BEGIN_SRC emacs-lisp
  (defun xah-syntax-color-hex ()
    "Syntax color hex color spec such as „Äå#ff1100„Äç in current buffer."
    (interactive)
    (font-lock-add-keywords
     nil
     '(("#[abcdef[:digit:]]\\{6\\}"
        (0 (put-text-property
            (match-beginning 0)
            (match-end 0)
            'face (list :background (match-string-no-properties 0)))))))
    (font-lock-fontify-buffer))
#+END_SRC
** Save Spelling to Dictionary
Basically uses ispell on the previous misspelled word, and stores the change
into abbrev for future autocorrection.
http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

#+BEGIN_SRC emacs-lisp
  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev.  Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer.  You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (thing-at-point 'word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word))
        (setq aft (thing-at-point 'word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
#+END_SRC
** Actually Quit Minibuffer
#+BEGIN_SRC emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
#+END_SRC
** Move to Start of Text
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (defun sk/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.
  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.
  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+END_SRC
** Auto-correct DOuble CAps
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (defun sk/dcaps-to-scaps ()
    "Convert word in DOuble CApitals to Single Capitals."
    (interactive)
    (and (= ?w (char-syntax (char-before)))
         (save-excursion
           (and (if (called-interactively-p)
                    (skip-syntax-backward "w")
                  (= -3 (skip-syntax-backward "w")))
                (let (case-fold-search)
                  (looking-at "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
                (capitalize-word 1)))))
#+END_SRC
* Custom Minor Modes
** Dubcaps Mode
Taken from http://sriramkswamy.github.io/dotemacs/#orgheadline18
#+BEGIN_SRC emacs-lisp
  (define-minor-mode sk/dubcaps-mode
    "Toggle `sk/dubcaps-mode'.  Converts words in DOuble CApitals to
  Single Capitals as you type."
    :init-value nil
    :lighter (" DC")
    (if sk/dubcaps-mode
        (add-hook 'post-self-insert-hook #'sk/dcaps-to-scaps nil 'local)
      (remove-hook 'post-self-insert-hook #'sk/dcaps-to-scaps 'local)))

  (add-hook 'text-mode-hook #'sk/dubcaps-mode)
  (add-hook 'org-mode-hook #'sk/dubcaps-mode)
#+END_SRC
** Doxygen Mode
My personal creation that just updates doxygen whenever you save the current file.
#+BEGIN_SRC emacs-lisp
  (defun update-doxygen ()
    "Check to see if there is a Doxyfile in the current directory.
    If it does, update the file.  If not, generate a new Doxyfile."
    (interactive)
    (when doxygen-mode
      (if (file-exists-p "Doxyfile")
          (shell-command "doxygen Doxyfile > /dev/null")
        (progn
          (shell-command "doxygen -g > /dev/null; doxygen Doxyfile > /dev/null")
          (message "Created new Doxyfile")))))

  (define-minor-mode doxygen-mode
    "Update the Doxyfile after each save."
    :lighter " Doxygen"
    (add-hook 'after-save-hook 'update-doxygen))
#+END_SRC
* Custom Keybinds
Note that there are plenty more scattered around, so this is more for built-in
or custom functions.
** Motion and Formatting
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-a") 'sk/smarter-move-beginning-of-line)
  (global-set-key (kbd "s-r") 'clean-buffer)
  (global-set-key (kbd "M-Q") 'auto-fill-mode)
#+END_SRC
** Programming
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c /") 'comment-line)
  (global-set-key (kbd "C-c C-/") 'comment-or-uncomment-region)
  (global-set-key (kbd "<f5>") 'compile)
#+END_SRC
** Start Applications
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-c") 'calc)
#+END_SRC
** Strengthen Escape
#+BEGIN_SRC emacs-lisp
  (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
  (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC
* Org-Contacts
It appears like this may be deprecated or something, but I've only been able to
find the raw file lying around on the Org-Mode site. Hopefully things will work?

#+BEGIN_SRC emacs-lisp
  ;;; org-contacts.el --- Contacts management

  ;; Copyright (C) 2010-2014 Julien Danjou <julien@danjou.info>

  ;; Author: Julien Danjou <julien@danjou.info>
  ;; Keywords: outlines, hypermedia, calendar
  ;;
  ;; This file is NOT part of GNU Emacs.
  ;;
  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Commentary:

  ;; This file contains the code for managing your contacts into Org-mode.

  ;; To enter new contacts, you can use `org-capture' and a minimal template just like
  ;; this:

  ;;         ("c" "Contacts" entry (file "~/Org/contacts.org")
  ;;          "* %(org-contacts-template-name)
  ;; :PROPERTIES:
  ;; :EMAIL: %(org-contacts-template-email)
  ;; :END:")))
  ;;
  ;; You can also use a complex template, for example:
  ;;
  ;;         ("c" "Contacts" entry (file "~/Org/contacts.org")
  ;;          "* %(org-contacts-template-name)
  ;; :PROPERTIES:
  ;; :EMAIL: %(org-contacts-template-email)
  ;; :PHONE:
  ;; :ALIAS:
  ;; :NICKNAME:
  ;; :IGNORE:
  ;; :ICON:
  ;; :NOTE:
  ;; :ADDRESS:
  ;; :BIRTHDAY:
  ;; :END:")))
  ;;
  ;;; Code:

  (require 'cl-lib)
  (require 'org)
  (require 'gnus-util)
  (require 'gnus-art)
  (require 'mail-utils)
  (require 'org-agenda)
  (require 'org-capture)

  (defgroup org-contacts nil
    "Options about contacts management."
    :group 'org)

  (defcustom org-contacts-files nil
    "List of Org files to use as contacts source.
  When set to nil, all your Org files will be used."
    :type '(repeat file)
    :group 'org-contacts)

  (defcustom org-contacts-email-property "EMAIL"
    "Name of the property for contact email address."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-tel-property "PHONE"
    "Name of the property for contact phone number."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-address-property "ADDRESS"
    "Name of the property for contact address."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-birthday-property "BIRTHDAY"
    "Name of the property for contact birthday date."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-note-property "NOTE"
    "Name of the property for contact note."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-alias-property "ALIAS"
    "Name of the property for contact name alias."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-ignore-property "IGNORE"
    "Name of the property, which values will be ignored when
  completing or exporting to vcard."
    :type 'string
    :group 'org-contacts)


  (defcustom org-contacts-birthday-format "Birthday: %l (%Y)"
    "Format of the anniversary agenda entry.
  The following replacements are available:

    %h - Heading name
    %l - Link to the heading
    %y - Number of year
    %Y - Number of year (ordinal)"
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-last-read-mail-property "LAST_READ_MAIL"
    "Name of the property for contact last read email link storage."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-icon-property "ICON"
    "Name of the property for contact icon."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-nickname-property "NICKNAME"
    "Name of the property for IRC nickname match."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-icon-size 32
    "Size of the contacts icons."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-icon-use-gravatar (fboundp 'gravatar-retrieve)
    "Whether use Gravatar to fetch contact icons."
    :type 'boolean
    :group 'org-contacts)

  (defcustom org-contacts-completion-ignore-case t
    "Ignore case when completing contacts."
    :type 'boolean
    :group 'org-contacts)

  (defcustom org-contacts-group-prefix "+"
    "Group prefix."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-tags-props-prefix "#"
    "Tags and properties prefix."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-matcher
    (mapconcat #'identity
           (mapcar (lambda (x) (concat x "<>\"\""))
               (list org-contacts-email-property
                 org-contacts-alias-property
                 org-contacts-tel-property
                 org-contacts-address-property
                 org-contacts-birthday-property))
           "|")
    "Matching rule for finding heading that are contacts.
  This can be a tag name, or a property check."
    :type 'string
    :group 'org-contacts)

  (defcustom org-contacts-email-link-description-format "%s (%d)"
    "Format used to store links to email.
  This overrides `org-email-link-description-format' if set."
    :group 'org-contacts
    :type 'string)

  (defcustom org-contacts-vcard-file "contacts.vcf"
    "Default file for vcard export."
    :group 'org-contacts
    :type 'file)

  (defcustom org-contacts-enable-completion t
    "Enable or not the completion in `message-mode' with `org-contacts'."
    :group 'org-contacts
    :type 'boolean)

  (defcustom org-contacts-complete-functions
    '(org-contacts-complete-group org-contacts-complete-tags-props org-contacts-complete-name)
    "List of functions used to complete contacts in `message-mode'."
    :group 'org-contacts
    :type 'hook)

  ;; Decalre external functions and variables
  (declare-function org-reverse-string "org")
  (declare-function diary-ordinal-suffix "ext:diary-lib")
  (declare-function wl-summary-message-number "ext:wl-summary")
  (declare-function wl-address-header-extract-address "ext:wl-address")
  (declare-function wl-address-header-extract-realname "ext:wl-address")
  (declare-function erc-buffer-list "ext:erc")
  (declare-function erc-get-channel-user-list "ext:erc")
  (declare-function google-maps-static-show "ext:google-maps-static")
  (declare-function elmo-message-field "ext:elmo-pipe")
  (declare-function std11-narrow-to-header "ext:std11")
  (declare-function std11-fetch-field "ext:std11")

  (defconst org-contacts-property-values-separators "[,; \f\t\n\r\v]+"
    "The default value of separators for `org-contacts-split-property'.

  A regexp matching strings of whitespace, `,' and `;'.")

  (defvar org-contacts-keymap
    (let ((map (make-sparse-keymap)))
      (define-key map "M" 'org-contacts-view-send-email)
      (define-key map "i" 'org-contacts-view-switch-to-irc-buffer)
      map)
    "The keymap used in `org-contacts' result list.")

  (defvar org-contacts-db nil
    "Org Contacts database.")

  (defvar org-contacts-last-update nil
    "Last time the Org Contacts database has been updated.")

  (defun org-contacts-files ()
    "Return list of Org files to use for contact management."
    (or org-contacts-files (org-agenda-files t 'ifmode)))

  (defun org-contacts-db-need-update-p ()
    "Determine whether `org-contacts-db' needs to be refreshed."
    (or (null org-contacts-last-update)
        (cl-find-if (lambda (file)
               (or (time-less-p org-contacts-last-update
                        (elt (file-attributes file) 5))))
             (org-contacts-files))
        (org-contacts-db-has-dead-markers-p org-contacts-db)))

  (defun org-contacts-db-has-dead-markers-p (org-contacts-db)
    "Returns t if at least one dead marker is found in
  ORG-CONTACTS-DB. A dead marker in this case is a marker pointing
  to dead or no buffer."
      ;; Scan contacts list looking for dead markers, and return t at first found.
      (catch 'dead-marker-found
        (while org-contacts-db
          (unless (marker-buffer (nth 1 (car org-contacts-db)))
            (throw 'dead-marker-found t))
          (setq org-contacts-db (cdr org-contacts-db)))
        nil))

  (defun org-contacts-db ()
    "Return the latest Org Contacts Database."
    (let* ((org--matcher-tags-todo-only nil)
       (contacts-matcher (cdr (org-make-tags-matcher org-contacts-matcher)))
       result)
      (when (org-contacts-db-need-update-p)
        (let ((progress-reporter
           (make-progress-reporter "Updating Org Contacts Database..." 0 (length org-contacts-files)))
          (i 0))
      (dolist (file (org-contacts-files))
        (if (catch 'nextfile
                  ;; if file doesn't exist and the user agrees to removing it
                  ;; from org-agendas-list, 'nextfile is thrown.  Catch it here
                  ;; and skip processing the file.
                  ;;
                  ;; TODO: suppose that the user has set an org-contacts-files
                  ;; list that contains an element that doesn't exist in the
                  ;; file system: in that case, the org-agenda-files list could
                  ;; be updated (and saved to the customizations of the user) if
                  ;; it contained the same file even though the org-agenda-files
                  ;; list wasn't actually used.  I don't think it is normal that
                  ;; org-contacts updates org-agenda-files in this case, but
                  ;; short of duplicating org-check-agenda-files and
                  ;; org-remove-files, I don't know how to avoid it.
                  ;;
                  ;; A side effect of the TODO is that the faulty
                  ;; org-contacts-files list never gets updated and thus the
                  ;; user is always queried about the missing files when
                  ;; org-contacts-db-need-update-p returns true.
                  (org-check-agenda-file file))
                (message "Skipped %s removed from org-agenda-files list."
                         (abbreviate-file-name file))
          (with-current-buffer (org-get-agenda-file-buffer file)
            (unless (eq major-mode 'org-mode)
          (error "File %s is not in `org-mode'" file))
            (setf result
              (append result
                  (org-scan-tags 'org-contacts-at-point
                         contacts-matcher
                         org--matcher-tags-todo-only)))))
        (progress-reporter-update progress-reporter (setq i (1+ i))))
      (setf org-contacts-db result
            org-contacts-last-update (current-time))
      (progress-reporter-done progress-reporter)))
      org-contacts-db))

  (defun org-contacts-at-point (&optional pom)
    "Return the contacts at point-or-marker POM or current position
  if nil."
    (setq pom (or pom (point)))
    (org-with-point-at pom
      (list (org-get-heading t) (set-marker (make-marker) pom) (org-entry-properties pom 'all))))

  (defun org-contacts-filter (&optional name-match tags-match prop-match)
    "Search for a contact matching any of NAME-MATCH, TAGS-MATCH, PROP-MATCH.
  If all match values are nil, return all contacts.

  The optional PROP-MATCH argument is a single (PROP . VALUE) cons
  cell corresponding to the contact properties.
  "
    (if (and (null name-match)
         (null prop-match)
         (null tags-match))
        (org-contacts-db)
      (cl-loop for contact in (org-contacts-db)
           if (or
           (and name-match
                (string-match-p name-match
                        (first contact)))
           (and prop-match
                (cl-find-if (lambda (prop)
                       (and (string= (car prop-match) (car prop))
                        (string-match-p (cdr prop-match) (cdr prop))))
                     (caddr contact)))
           (and tags-match
                (cl-find-if (lambda (tag)
                       (string-match-p tags-match tag))
                     (org-split-string
                      (or (cdr (assoc-string "ALLTAGS" (caddr contact))) "") ":"))))
           collect contact)))

  (when (not (fboundp 'completion-table-case-fold))
    ;; That function is new in Emacs 24...
    (defun completion-table-case-fold (table &optional dont-fold)
      (lambda (string pred action)
        (let ((completion-ignore-case (not dont-fold)))
      (complete-with-action action table string pred)))))

  (defun org-contacts-try-completion-prefix (to-match collection &optional predicate)
    "Custom implementation of `try-completion'.
  This version works only with list and alist and it looks at all
  prefixes rather than just the beginning of the string."
    (cl-loop with regexp = (concat "\\b" (regexp-quote to-match))
         with ret = nil
         with ret-start = nil
         with ret-end = nil

         for el in collection
         for string = (if (listp el) (car el) el)

         for start = (when (or (null predicate) (funcall predicate string))
               (string-match regexp string))

         if start
         do (let ((end (match-end 0))
              (len (length string)))
          (if (= end len)
              (cl-return t)
            (cl-destructuring-bind (string start end)
                (if (null ret)
                (values string start end)
              (org-contacts-common-substring
               ret ret-start ret-end
               string start end))
              (setf ret string
                ret-start start
                ret-end end))))

         finally (cl-return
              (replace-regexp-in-string "\\`[ \t\n]*" "" ret))))

  (defun org-contacts-compare-strings (s1 start1 end1 s2 start2 end2 &optional ignore-case)
    "Compare the contents of two strings, using `compare-strings'.

  This function works like `compare-strings' excepted that it
  returns a cons.
  - The CAR is the number of characters that match at the beginning.
  - The CDR is T is the two strings are the same and NIL otherwise."
    (let ((ret (compare-strings s1 start1 end1 s2 start2 end2 ignore-case)))
      (if (eq ret t)
      (cons (or end1 (length s1)) t)
        (cons (1- (abs ret)) nil))))

  (defun org-contacts-common-substring (s1 start1 end1 s2 start2 end2)
    "Extract the common substring between S1 and S2.

  This function extracts the common substring between S1 and S2 and
  adjust the part that remains common.

  START1 and END1 delimit the part in S1 that we know is common
  between the two strings. This applies to START2 and END2 for S2.

  This function returns a list whose contains:
  - The common substring found.
  - The new value of the start of the known inner substring.
  - The new value of the end of the known inner substring."
    ;; Given two strings:
    ;; s1: "foo bar baz"
    ;; s2: "fooo bar baz"
    ;; and the inner substring is "bar"
    ;; then: start1 = 4, end1 = 6, start2 = 5, end2 = 7
    ;;
    ;; To find the common substring we will compare two substrings:
    ;; " oof" and " ooof" to find the beginning of the common substring.
    ;; " baz" and " baz" to find the end of the common substring.
    (let* ((len1 (length s1))
       (start1 (or start1 0))
       (end1 (or end1 len1))

       (len2 (length s2))
       (start2 (or start2 0))
       (end2 (or end2 len2))

       (new-start (car (org-contacts-compare-strings
                (substring (org-reverse-string s1) (- len1 start1)) nil nil
                (substring (org-reverse-string s2) (- len2 start2)) nil nil)))

       (new-end (+ end1 (car (org-contacts-compare-strings
                  (substring s1 end1) nil nil
                  (substring s2 end2) nil nil)))))
      (list (substring s1 (- start1 new-start) new-end)
        new-start
        (+ new-start (- end1 start1)))))

  (defun org-contacts-all-completions-prefix (to-match collection &optional predicate)
    "Custom version of `all-completions'.
  This version works only with list and alist and it looks at all
  prefixes rather than just the beginning of the string."
    (cl-loop with regexp = (concat "\\b" (regexp-quote to-match))
         for el in collection
         for string = (if (listp el) (car el) el)
         for match? = (when (and (or (null predicate) (funcall predicate string)))
                (string-match regexp string))
         if match?
         collect (progn
               (let ((end (match-end 0)))
                 (org-no-properties string)
                 (when (< end (length string))
               ;; Here we add a text property that will be used
               ;; later to highlight the character right after
               ;; the common part between each addresses.
               ;; See `org-contacts-display-sort-function'.
               (put-text-property end (1+ end) 'org-contacts-prefix 't string)))
               string)))

  (defun org-contacts-make-collection-prefix (collection)
    "Make a collection function from COLLECTION which will match on prefixes."
    (lexical-let ((collection collection))
      (lambda (string predicate flag)
        (cond ((eq flag nil)
           (org-contacts-try-completion-prefix string collection predicate))
          ((eq flag t)
           ;; `org-contacts-all-completions-prefix' has already been
           ;; used to compute `all-completions'.
           collection)
          ((eq flag 'lambda)
           (org-contacts-test-completion-prefix string collection predicate))
          ((and (listp flag) (eq (car flag) 'boundaries))
           (cl-destructuring-bind (to-ignore &rest suffix)
           flag
             (org-contacts-boundaries-prefix string collection predicate suffix)))
          ((eq flag 'metadata)
           (org-contacts-metadata-prefix string collection predicate))
          (t nil			; operation unsupported
             )))))

  (defun org-contacts-display-sort-function (completions)
    "Sort function for contacts display."
    (mapcar (lambda (string)
          (cl-loop with len = (1- (length string))
               for i upfrom 0 to len
               if (memq 'org-contacts-prefix
                    (text-properties-at i string))
               do (set-text-properties
               i (1+ i)
               (list 'font-lock-face
                     (if (char-equal (aref string i)
                             (string-to-char " "))
                     ;; Spaces can't be bold.
                     'underline
                   'bold)) string)
               else
               do (set-text-properties i (1+ i) nil string)
               finally (cl-return string)))
        completions))

  (defun org-contacts-test-completion-prefix (string collection predicate)
    (cl-find-if (lambda (el)
          (and (or (null predicate) (funcall predicate el))
               (string= string el)))
            collection))

  (defun org-contacts-boundaries-prefix (string collection predicate suffix)
    (list* 'boundaries (completion-boundaries string collection predicate suffix)))

  (defun org-contacts-metadata-prefix (string collection predicate)
    '(metadata .
           ((cycle-sort-function . org-contacts-display-sort-function)
            (display-sort-function . org-contacts-display-sort-function))))

  (defun org-contacts-complete-group (start end string)
    "Complete text at START from a group.

  A group FOO is composed of contacts with the tag FOO."
    (let* ((completion-ignore-case org-contacts-completion-ignore-case)
       (group-completion-p (string-match-p
                    (concat "^" org-contacts-group-prefix) string)))
      (when group-completion-p
        (let ((completion-list
           (all-completions
            string
            (mapcar (lambda (group)
              (propertize (concat org-contacts-group-prefix group)
                      'org-contacts-group group))
                (org-uniquify
                 (cl-loop for contact in (org-contacts-filter)
                  nconc (org-split-string
                         (or (cdr (assoc-string "ALLTAGS" (caddr contact))) "") ":")))))))
      (list start end
            (if (= (length completion-list) 1)
            ;; We've found the correct group, returns the address
            (lexical-let ((tag (get-text-property 0 'org-contacts-group
                              (car completion-list))))
              (lambda (string pred &optional to-ignore)
                (mapconcat 'identity
                   (cl-loop for contact in (org-contacts-filter
                                nil
                                tag)
                        ;; The contact name is always the car of the assoc-list
                        ;; returned by `org-contacts-filter'.
                        for contact-name = (car contact)
                        ;; Grab the first email of the contact
                        for email = (org-contacts-strip-link
                                 (or (car (org-contacts-split-property
                                   (or
                                    (cdr (assoc-string org-contacts-email-property
                                               (cl-caddr contact)))
                                    ""))) ""))
                        ;; If the user has an email address, append USER <EMAIL>.
                        if email collect (org-contacts-format-email contact-name email))
                   ", ")))
          ;; We haven't found the correct group
          (completion-table-case-fold completion-list
                          (not org-contacts-completion-ignore-case))))))))

  (defun org-contacts-complete-tags-props (start end string)
    "Insert emails that match the tags expression.

  For example: FOO-BAR will match entries tagged with FOO but not
  with BAR.

  See (org) Matching tags and properties for a complete
  description."
    (let* ((completion-ignore-case org-contacts-completion-ignore-case)
       (completion-p (string-match-p
              (concat "^" org-contacts-tags-props-prefix) string)))
      (when completion-p
        (let ((result
           (mapconcat
            'identity
            (cl-loop for contact in (org-contacts-db)
                 for contact-name = (car contact)
                 for email = (org-contacts-strip-link (or (car (org-contacts-split-property
                                        (or
                                         (cdr (assoc-string org-contacts-email-property
                                                (cl-caddr contact)))
                                         ""))) ""))
                 for tags = (cdr (assoc "TAGS" (nth 2 contact)))
                 for tags-list = (if tags
                         (split-string (substring (cdr (assoc "TAGS" (nth 2 contact))) 1 -1) ":")
                       '())
                 for marker = (nth 1 contact)
                 if (with-current-buffer (marker-buffer marker)
                  (save-excursion
                    (goto-char marker)
                    (let (todo-only)
                  (eval (cdr (org-make-tags-matcher (cl-subseq string 1)))))))
                 collect (org-contacts-format-email contact-name email))
            ",")))
      (when (not (string= "" result))
        ;; return (start end function)
        (lexical-let* ((to-return result))
          (list start end
            (lambda (string pred &optional to-ignore) to-return))))))))

  (defun org-contacts-remove-ignored-property-values (ignore-list list)
    "Remove all ignore-list's elements from list and you can use
     regular expressions in the ignore list."
    (cl-remove-if (lambda (el)
            (cl-find-if (lambda (x)
                   (string-match-p x el))
                     ignore-list))
          list))

  (defun org-contacts-complete-name (start end string)
    "Complete text at START with a user name and email."
    (let* ((completion-ignore-case org-contacts-completion-ignore-case)
           (completion-list
        (cl-loop for contact in (org-contacts-filter)
             ;; The contact name is always the car of the assoc-list
             ;; returned by `org-contacts-filter'.
             for contact-name = (car contact)

             ;; Build the list of the email addresses which has
             ;; been expired
             for ignore-list = (org-contacts-split-property
                        (or (cdr (assoc-string org-contacts-ignore-property
                                   (nth 2 contact))) ""))
             ;; Build the list of the user email addresses.
             for email-list = (org-contacts-remove-ignored-property-values
                       ignore-list
                       (org-contacts-split-property
                        (or (cdr (assoc-string org-contacts-email-property
                                   (nth 2 contact))) "")))
             ;; If the user has email addresses√¢‚Ç¨¬¶
             if email-list
             ;; √¢‚Ç¨¬¶ append a list of USER <EMAIL>.
             nconc (cl-loop for email in email-list
                    collect (org-contacts-format-email contact-name (org-contacts-strip-link email)))))
       (completion-list (org-contacts-all-completions-prefix
                 string
                 (org-uniquify completion-list))))
      (when completion-list
        (list start end
          (org-contacts-make-collection-prefix completion-list)))))

  (defun org-contacts-message-complete-function (&optional start)
    "Function used in `completion-at-point-functions' in `message-mode'."
    ;; Avoid to complete in `post-command-hook'.
    (when completion-in-region-mode
      (remove-hook 'post-command-hook #'completion-in-region--postch))
    (let ((mail-abbrev-mode-regexp
           "^\\(Resent-To\\|To\\|B?Cc\\|Reply-To\\|From\\|Mail-Followup-To\\|Mail-Copies-To\\|Disposition-Notification-To\\|Return-Receipt-To\\):"))
      (when (mail-abbrev-in-expansion-header-p)
        (lexical-let*
        ((end (point))
         (start (or start
                (save-excursion
              (re-search-backward "\\(\\`\\|[\n:,]\\)[ \t]*")
              (goto-char (match-end 0))
              (point))))
         (string (buffer-substring start end)))
      (run-hook-with-args-until-success
       'org-contacts-complete-functions start end string)))))

  (defun org-contacts-gnus-get-name-email ()
    "Get name and email address from Gnus message."
    (if (gnus-alive-p)
        (gnus-with-article-headers
          (mail-extract-address-components
           (or (mail-fetch-field "From") "")))))

  (defun org-contacts-gnus-article-from-get-marker ()
    "Return a marker for a contact based on From."
    (let* ((address (org-contacts-gnus-get-name-email))
           (name (car address))
           (email (cadr address)))
      (cl-cadar (or (org-contacts-filter
             nil
             nil
             (cons org-contacts-email-property (concat "\\b" (regexp-quote email) "\\b")))
            (when name
              (org-contacts-filter
               (concat "^" name "$")))))))

  (defun org-contacts-gnus-article-from-goto ()
    "Go to contact in the From address of current Gnus message."
    (interactive)
    (let ((marker (org-contacts-gnus-article-from-get-marker)))
      (when marker
        (switch-to-buffer-other-window (marker-buffer marker))
        (goto-char marker)
        (when (eq major-mode 'org-mode) (org-show-context 'agenda)))))

  (with-no-warnings (defvar date)) ;; unprefixed, from calendar.el
  (defun org-contacts-anniversaries (&optional field format)
    "Compute FIELD anniversary for each contact, returning FORMAT.
  Default FIELD value is \"BIRTHDAY\".

  Format is a string matching the following format specification:

    %h - Heading name
    %l - Link to the heading
    %y - Number of year
    %Y - Number of year (ordinal)"
    (let ((calendar-date-style 'american)
          (entry ""))
      (unless format (setq format org-contacts-birthday-format))
      (cl-loop for contact in (org-contacts-filter)
           for anniv = (let ((anniv (cdr (assoc-string
                          (or field org-contacts-birthday-property)
                          (nth 2 contact)))))
                 (when anniv
                   (calendar-gregorian-from-absolute
                    (org-time-string-to-absolute anniv))))
           ;; Use `diary-anniversary' to compute anniversary.
           if (and anniv (apply 'diary-anniversary anniv))
           collect (format-spec format
                    `((?l . ,(org-with-point-at (cadr contact) (org-store-link nil)))
                      (?h . ,(car contact))
                      (?y . ,(- (calendar-extract-year date)
                            (calendar-extract-year anniv)))
                      (?Y . ,(let ((years (- (calendar-extract-year date)
                                 (calendar-extract-year anniv))))
                           (format "%d%s" years (diary-ordinal-suffix years)))))))))

  (defun org-completing-read-date (prompt collection
                                          &optional predicate require-match initial-input
                                          hist def inherit-input-method)
    "Like `completing-read' but reads a date.
  Only PROMPT and DEF are really used."
    (org-read-date nil nil nil prompt nil def))

  (add-to-list 'org-property-set-functions-alist
               `(,org-contacts-birthday-property . org-completing-read-date))

  (defun org-contacts-template-name (&optional return-value)
    "Try to return the contact name for a template.
  If not found return RETURN-VALUE or something that would ask the user."
    (or (car (org-contacts-gnus-get-name-email))
        return-value
        "%^{Name}"))

  (defun org-contacts-template-email (&optional return-value)
    "Try to return the contact email for a template.
  If not found return RETURN-VALUE or something that would ask the user."
    (or (cadr (org-contacts-gnus-get-name-email))
        return-value
        (concat "%^{" org-contacts-email-property "}p")))

  (defun org-contacts-gnus-store-last-mail ()
    "Store a link between mails and contacts.

  This function should be called from `gnus-article-prepare-hook'."
    (let ((marker (org-contacts-gnus-article-from-get-marker)))
      (when marker
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char marker)
            (let* ((org-email-link-description-format (or org-contacts-email-link-description-format
                                                          org-email-link-description-format))
                   (link (gnus-with-article-buffer (org-store-link nil))))
              (org-set-property org-contacts-last-read-mail-property link)))))))

  (defun org-contacts-icon-as-string ()
    "Return the contact icon as a string."
    (let ((image (org-contacts-get-icon)))
      (concat
       (propertize "-" 'display
                   (append
                    (if image
                        image
                      `'(space :width (,org-contacts-icon-size)))
                    '(:ascent center)))
       " ")))

  ;;;###autoload
  (defun org-contacts (name)
    "Create agenda view for contacts matching NAME."
    (interactive (list (read-string "Name: ")))
    (let ((org-agenda-files (org-contacts-files))
          (org-agenda-skip-function
           (lambda () (org-agenda-skip-if nil `(notregexp ,name))))
          (org-agenda-prefix-format (propertize
                     "%(org-contacts-icon-as-string)% s%(org-contacts-irc-number-of-unread-messages) "
                     'keymap org-contacts-keymap))
          (org-agenda-overriding-header
           (or org-agenda-overriding-header
               (concat "List of contacts matching `" name "':"))))
      (setq org-agenda-skip-regexp name)
      (org-tags-view nil org-contacts-matcher)
      (with-current-buffer org-agenda-buffer-name
        (setq org-agenda-redo-command
              (list 'org-contacts name)))))

  (defun org-contacts-completing-read (prompt
                                       &optional predicate
                                       initial-input hist def inherit-input-method)
    "Call `completing-read' with contacts name as collection."
    (org-completing-read
     prompt (org-contacts-filter) predicate t initial-input hist def inherit-input-method))

  (defun org-contacts-format-name (name)
    "Trim any local formatting to get a bare NAME."
    ;; Remove radio targets characters
    (replace-regexp-in-string org-radio-target-regexp "\\1" name))

  (defun org-contacts-format-email (name email)
    "Format an EMAIL address corresponding to NAME."
    (unless email
      (error "`email' cannot be nul"))
    (if name
        (concat (org-contacts-format-name name) " <" email ">")
      email))

  (defun org-contacts-check-mail-address (mail)
    "Add MAIL address to contact at point if it does not have it."
    (let ((mails (org-entry-get (point) org-contacts-email-property)))
      (unless (member mail (split-string mails))
        (when (yes-or-no-p
               (format "Do you want to add this address to %s?" (org-get-heading t)))
          (org-set-property org-contacts-email-property (concat mails " " mail))))))

  (defun org-contacts-gnus-check-mail-address ()
    "Check that contact has the current address recorded.
  This function should be called from `gnus-article-prepare-hook'."
    (let ((marker (org-contacts-gnus-article-from-get-marker)))
      (when marker
        (org-with-point-at marker
          (org-contacts-check-mail-address (cadr (org-contacts-gnus-get-name-email)))))))

  (defun org-contacts-gnus-insinuate ()
    "Add some hooks for Gnus user.
  This adds `org-contacts-gnus-check-mail-address' and
  `org-contacts-gnus-store-last-mail' to
  `gnus-article-prepare-hook'.  It also adds a binding on `;' in
  `gnus-summary-mode-map' to `org-contacts-gnus-article-from-goto'"
    (require 'gnus)
    (require 'gnus-art)
    (define-key gnus-summary-mode-map ";" 'org-contacts-gnus-article-from-goto)
    (add-hook 'gnus-article-prepare-hook 'org-contacts-gnus-check-mail-address)
    (add-hook 'gnus-article-prepare-hook 'org-contacts-gnus-store-last-mail))

  (defun org-contacts-setup-completion-at-point ()
    "Add `org-contacts-message-complete-function' as a new function
  to complete the thing at point."
    (add-to-list 'completion-at-point-functions
             'org-contacts-message-complete-function))

  (defun org-contacts-unload-hook ()
    (remove-hook 'message-mode-hook 'org-contacts-setup-completion-at-point))

  (when (and org-contacts-enable-completion
         (boundp 'completion-at-point-functions))
    (add-hook 'message-mode-hook 'org-contacts-setup-completion-at-point))

  (defun org-contacts-wl-get-from-header-content ()
    "Retrieve the content of the `From' header of an email.
  Works from wl-summary-mode and mime-view-mode - that is while viewing email.
  Depends on Wanderlust been loaded."
    (with-current-buffer (org-capture-get :original-buffer)
      (cond
       ((eq major-mode 'wl-summary-mode) (when (and (boundp 'wl-summary-buffer-elmo-folder)
                            wl-summary-buffer-elmo-folder)
                                           (elmo-message-field
                                            wl-summary-buffer-elmo-folder
                                            (wl-summary-message-number)
                                            'from)))
       ((eq major-mode 'mime-view-mode) (std11-narrow-to-header)
        (prog1
        (std11-fetch-field "From")
      (widen))))))

  (defun org-contacts-wl-get-name-email ()
    "Get name and email address from Wanderlust email.
  See `org-contacts-wl-get-from-header-content' for limitations."
    (let ((from (org-contacts-wl-get-from-header-content)))
      (when from
        (list (wl-address-header-extract-realname from)
          (wl-address-header-extract-address from)))))

  (defun org-contacts-template-wl-name (&optional return-value)
    "Try to return the contact name for a template from wl.
  If not found, return RETURN-VALUE or something that would ask the
  user."
    (or (car (org-contacts-wl-get-name-email))
        return-value
        "%^{Name}"))

  (defun org-contacts-template-wl-email (&optional return-value)
    "Try to return the contact email for a template from Wanderlust.
  If not found return RETURN-VALUE or something that would ask the user."
    (or (cadr (org-contacts-wl-get-name-email))
        return-value
        (concat "%^{" org-contacts-email-property "}p")))

  (defun org-contacts-view-send-email (&optional ask)
    "Send email to the contact at point.
  If ASK is set, ask for the email address even if there's only one
  address."
    (interactive "P")
    (let ((marker (org-get-at-bol 'org-hd-marker)))
      (org-with-point-at marker
        (let ((emails (org-entry-get (point) org-contacts-email-property)))
          (if emails
              (let ((email-list (org-contacts-split-property emails)))
                (if (and (= (length email-list) 1) (not ask))
                    (compose-mail (org-contacts-format-email
                                   (org-get-heading t) emails))
                  (let ((email (completing-read "Send mail to which address: " email-list)))
            (setq email (org-contacts-strip-link email))
                    (org-contacts-check-mail-address email)
                    (compose-mail (org-contacts-format-email (org-get-heading t) email)))))
            (error (format "This contact has no mail address set (no %s property)"
                           org-contacts-email-property)))))))

  (defun org-contacts-get-icon (&optional pom)
    "Get icon for contact at POM."
    (setq pom (or pom (point)))
    (catch 'icon
      ;; Use `org-contacts-icon-property'
      (let ((image-data (org-entry-get pom org-contacts-icon-property)))
        (when image-data
          (throw 'icon
                 (if (fboundp 'gnus-rescale-image)
                     (gnus-rescale-image (create-image image-data)
                                         (cons org-contacts-icon-size org-contacts-icon-size))
                   (create-image image-data)))))
      ;; Next, try Gravatar
      (when org-contacts-icon-use-gravatar
        (let* ((gravatar-size org-contacts-icon-size)
               (email-list (org-entry-get pom org-contacts-email-property))
               (gravatar
                (when email-list
                  (loop for email in (org-contacts-split-property email-list)
                        for gravatar = (gravatar-retrieve-synchronously (org-contacts-strip-link email))
                        if (and gravatar
                                (not (eq gravatar 'error)))
                        return gravatar))))
          (when gravatar (throw 'icon gravatar))))))

  (defun org-contacts-irc-buffer (&optional pom)
    "Get the IRC buffer associated with the entry at POM."
    (setq pom (or pom (point)))
    (let ((nick (org-entry-get pom org-contacts-nickname-property)))
      (when nick
        (let ((buffer (get-buffer nick)))
          (when buffer
            (with-current-buffer buffer
              (when (eq major-mode 'erc-mode)
                buffer)))))))

  (defun org-contacts-irc-number-of-unread-messages (&optional pom)
    "Return the number of unread messages for contact at POM."
    (when (boundp 'erc-modified-channels-alist)
      (let ((number (cadr (assoc (org-contacts-irc-buffer pom) erc-modified-channels-alist))))
        (if number
            (format (concat "%3d unread message" (if (> number 1) "s" " ") " ") number)
          (make-string 21 ? )))))

  (defun org-contacts-view-switch-to-irc-buffer ()
    "Switch to the IRC buffer of the current contact if it has one."
    (interactive)
    (let ((marker (org-get-at-bol 'org-hd-marker)))
      (org-with-point-at marker
        (switch-to-buffer-other-window (org-contacts-irc-buffer)))))

  (defun org-contacts-completing-read-nickname (prompt collection
                                                       &optional predicate require-match initial-input
                                                       hist def inherit-input-method)
    "Like `completing-read' but reads a nickname."
    (org-completing-read prompt (append collection (erc-nicknames-list)) predicate require-match
                         initial-input hist def inherit-input-method))

  (defun erc-nicknames-list ()
    "Return all nicknames of all ERC buffers."
    (loop for buffer in (erc-buffer-list)
      nconc (with-current-buffer buffer
          (loop for user-entry in (mapcar 'car (erc-get-channel-user-list))
                collect (elt user-entry 1)))))

  (add-to-list 'org-property-set-functions-alist
               `(,org-contacts-nickname-property . org-contacts-completing-read-nickname))

  (defun org-contacts-vcard-escape (str)
    "Escape ; , and \n in STR for the VCard format."
    ;; Thanks to this library for the regexp:
    ;; http://www.emacswiki.org/cgi-bin/wiki/bbdb-vcard-export.el
    (when str
      (replace-regexp-in-string
       "\n" "\\\\n"
       (replace-regexp-in-string "\\(;\\|,\\|\\\\\\)" "\\\\\\1" str))))

  (defun org-contacts-vcard-encode-name (name)
    "Try to encode NAME as VCard's N property.
  The N property expects

    FamilyName;GivenName;AdditionalNames;Prefix;Postfix.

  Org-contacts does not specify how to encode the name.  So we try
  to do our best."
    (concat (replace-regexp-in-string "\\(\\w+\\) \\(.*\\)" "\\2;\\1" name) ";;;"))

  (defun org-contacts-vcard-format (contact)
    "Formats CONTACT in VCard 3.0 format."
    (let* ((properties (nth 2 contact))
       (name (org-contacts-vcard-escape (car contact)))
       (n (org-contacts-vcard-encode-name name))
       (email (cdr (assoc-string org-contacts-email-property properties)))
       (tel (cdr (assoc-string org-contacts-tel-property properties)))
       (ignore-list (cdr (assoc-string org-contacts-ignore-property properties)))
       (ignore-list (when ignore-list
              (org-contacts-split-property ignore-list)))
       (note (cdr (assoc-string org-contacts-note-property properties)))
       (bday (org-contacts-vcard-escape (cdr (assoc-string org-contacts-birthday-property properties))))
       (addr (cdr (assoc-string org-contacts-address-property properties)))
       (nick (org-contacts-vcard-escape (cdr (assoc-string org-contacts-nickname-property properties))))
       (head (format "BEGIN:VCARD\nVERSION:3.0\nN:%s\nFN:%s\n" n name))
       emails-list result phones-list)
      (concat head
          (when email (progn
                (setq emails-list (org-contacts-remove-ignored-property-values ignore-list (org-contacts-split-property email)))
                (setq result "")
                (while emails-list
                  (setq result (concat result  "EMAIL:" (org-contacts-strip-link (car emails-list)) "\n"))
                  (setq emails-list (cdr emails-list)))
                result))
          (when addr
            (format "ADR:;;%s\n" (replace-regexp-in-string "\\, ?" ";" addr)))
          (when tel (progn
              (setq phones-list (org-contacts-remove-ignored-property-values ignore-list (org-contacts-split-property tel)))
              (setq result "")
              (while phones-list
                (setq result (concat result  "TEL:" (org-link-unescape (org-contacts-strip-link (car phones-list))) "\n"))
                (setq phones-list (cdr phones-list)))
              result))
          (when bday
            (let ((cal-bday (calendar-gregorian-from-absolute (org-time-string-to-absolute bday))))
          (format "BDAY:%04d-%02d-%02d\n"
              (calendar-extract-year cal-bday)
              (calendar-extract-month cal-bday)
              (calendar-extract-day cal-bday))))
          (when nick (format "NICKNAME:%s\n" nick))
          (when note (format "NOTE:%s\n" note))
          "END:VCARD\n\n")))

  (defun org-contacts-export-as-vcard (&optional name file to-buffer)
    "Export org contacts to V-Card 3.0.

  By default, all contacts are exported to `org-contacts-vcard-file'.

  When NAME is \\[universal-argument], prompts for a contact name.

  When NAME is \\[universal-argument] \\[universal-argument],
  prompts for a contact name and a file name where to export.

  When NAME is \\[universal-argument] \\[universal-argument]
  \\[universal-argument], prompts for a contact name and a buffer where to export.

  If the function is not called interactively, all parameters are
  passed to `org-contacts-export-as-vcard-internal'."
    (interactive "P")
    (when (called-interactively-p 'any)
      (cl-psetf name
            (when name
          (read-string "Contact name: "
                   (nth 0 (org-contacts-at-point))))
            file
            (when (equal name '(16))
          (read-file-name "File: " nil org-contacts-vcard-file))
            to-buffer
            (when (equal name '(64))
          (read-buffer "Buffer: "))))
    (org-contacts-export-as-vcard-internal name file to-buffer))

  (defun org-contacts-export-as-vcard-internal (&optional name file to-buffer)
    "Export all contacts matching NAME as VCard 3.0.
  If TO-BUFFER is nil, the content is written to FILE or
  `org-contacts-vcard-file'.  If TO-BUFFER is non-nil, the buffer
  is created and the VCard is written into that buffer."
    (let* ((filename (or file org-contacts-vcard-file))
       (buffer (if to-buffer
               (get-buffer-create to-buffer)
             (find-file-noselect filename))))
      (message "Exporting...")
      (set-buffer buffer)
      (let ((inhibit-read-only t)) (erase-buffer))
      (fundamental-mode)
      (when (fboundp 'set-buffer-file-coding-system)
        (set-buffer-file-coding-system coding-system-for-write))
      (loop for contact in (org-contacts-filter name)
        do (insert (org-contacts-vcard-format contact)))
      (if to-buffer
      (current-buffer)
        (progn (save-buffer) (kill-buffer)))))

  (defun org-contacts-show-map (&optional name)
    "Show contacts on a map.
  Requires google-maps-el."
    (interactive)
    (unless (fboundp 'google-maps-static-show)
      (error "`org-contacts-show-map' requires `google-maps-el'"))
    (google-maps-static-show
     :markers
     (cl-loop
      for contact in (org-contacts-filter name)
      for addr = (cdr (assoc-string org-contacts-address-property (nth 2 contact)))
      if addr
      collect (cons (list addr) (list :label (string-to-char (car contact)))))))

  (defun org-contacts-strip-link (link)
    "Remove brackets, description, link type and colon from an org
  link string and return the pure link target."
     (let (startpos colonpos endpos)
       (setq startpos (string-match (regexp-opt '("[[tel:" "[[mailto:")) link))
       (if startpos
           (progn
              (setq colonpos (string-match ":" link))
              (setq endpos (string-match "\\]" link))
              (if endpos (substring link (1+ colonpos) endpos) link))
           (progn
              (setq startpos (string-match "mailto:" link))
              (setq colonpos (string-match ":" link))
              (if startpos (substring link (1+ colonpos)) link)))))

  ;; Add the link type supported by org-contacts-strip-link
  ;; so everything is in order for its use in Org files
  (org-link-set-parameters "tel")

  (defun org-contacts-split-property (string &optional separators omit-nulls)
    "Custom version of `split-string'.
  Split a property STRING into sub-strings bounded by matches
  for SEPARATORS but keep Org links intact.

  The beginning and end of STRING, and each match for SEPARATORS, are
  splitting points.  The substrings matching SEPARATORS are removed, and
  the substrings between the splitting points are collected as a list,
  which is returned.

  If SEPARATORS is non-nil, it should be a regular expression
  matching text which separates, but is not part of, the
  substrings.  If nil it defaults to `org-contacts-property-values-separators',
  normally \"[,; \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.

  If OMIT-NULLS is t, zero-length substrings are omitted from the list \(so
  that for the default value of SEPARATORS leading and trailing whitespace
  are effectively trimmed).  If nil, all zero-length substrings are retained."
    (let* ((omit-nulls (if separators omit-nulls t))
       (rexp (or separators org-contacts-property-values-separators))
       (inputlist (split-string string rexp omit-nulls))
       (linkstring "")
       (bufferstring "")
       (proplist (list "")))
      (while inputlist
        (setq bufferstring (pop inputlist))
        (if (string-match "\\[\\[" bufferstring)
            (progn
              (setq linkstring (concat bufferstring " "))
              (while (not (string-match "\\]\\]" bufferstring))
                (setq bufferstring (pop inputlist))
                (setq linkstring (concat  linkstring bufferstring " ")))
              (setq proplist (cons (org-trim linkstring) proplist)))
          (setq proplist (cons bufferstring proplist))))
      (cdr (reverse proplist))))

  (provide 'org-contacts)
#+END_SRC

My customizations to it:

#+BEGIN_SRC emacs-lisp
  (setq org-contacts-files (list (concat org-directory "contacts.org")))
  (setq mu4e-org-contacts-file (car org-contacts-files))

  (defun my-mu4e-action-add-org-contact (msg)
    "Add an org-contact entry based on the From: address of the
   current message (in headers or view). You need to set
   `mu4e-org-contacts-file' to the full path to the file where you
   store your org-contacts."
    (unless (require 'org-capture nil 'noerror)
      (mu4e-error "org-capture is not available."))
    (unless mu4e-org-contacts-file
      (mu4e-error "`mu4e-org-contacts-file' is not defined."))
    (let* ((sender (car-safe (mu4e-message-field msg :from)))
           (name (car-safe sender)) (email (cdr-safe sender))
           (blurb
            (format
             (concat
              "* %%?%s\n"
              ":PROPERTIES:\n"
              ":NICKNAME:   %%^{Nickname}\n"
              ":EMAIL:      %s\n"
              ":HOME_PHONE: %%^{Home Phone}\n"
              ":CELL_PHONE: %%^{Cell Phone}\n"
              ":WORK_PHONE: %%^{Work Phone}\n"
              ":ADDRESS:    \n"
              ":CITY:       \n"
              ":STATE:      \n"
              ":ZIP:        \n"
              ":BIRTHDAY:   \n"
              ":NOTES:      \n"
              ":END:")
             (or name email "")
             (or email "")))
           (key "mu4e-add-org-contact-key")
           (org-capture-templates
            (append org-capture-templates
                    (list (list key "contacts" 'entry
                                (list 'file mu4e-org-contacts-file) blurb)))))
      (message "%S" org-capture-templates)
      (when (fboundp 'org-capture)
        (org-capture nil key))))

  (add-to-list 'mu4e-headers-actions
               '("org-contact-add" . my-mu4e-action-add-org-contact) t)
  (add-to-list 'mu4e-view-actions
               '("org-contact-add" . my-mu4e-action-add-org-contact) t)

  (push `("c" "Personal Contact" entry (file ,(car org-contacts-files))
          ,(concat "* %^{Name}\n"
                   ":PROPERTIES:\n"
                   ":NICKNAME:   %^{Nickname}\n"
                   ":EMAIL:      %^{Email}\n"
                   ":HOME_PHONE: %^{Home Phone}\n"
                   ":CELL_PHONE: %^{Cell Phone}\n"
                   ":WORK_PHONE: %^{Work Phone}\n"
                   ":ADDRESS:    %^{Address}\n"
                   ":CITY:       %^{City}\n"
                   ":STATE:      %^{State}\n"
                   ":ZIP:        %^{ZIP}\n"
                   ":BIRTHDAY:   %^{Birthday}t\n"
                   ":NOTES:      %?\n"
                   ":END:"))
        org-capture-templates)

  (push `("C" "Buisness Contact" entry (file ,(car org-contacts-files))
          ,(concat "* %^{Name}\n"
                   ":PROPERTIES:\n"
                   ":EMAIL:   %^{Email}\n"
                   ":PHONE:   %^{Phone}\n"
                   ":ADDRESS: %^{Address}\n"
                   ":CITY:    %^{City}\n"
                   ":STATE:   %^{State}\n"
                   ":ZIP:     %^{ZIP}\n"
                   ":NOTES:   %?\n"
                   ":END:"))
        org-capture-templates)
#+END_SRC
* Bucket List
Things I'd like to fix/improve when I have the time and know-how.

** Cool Packages
- https://github.com/twada/coverlay.el
  - shows code coverage according to an lcov file
- https://gitlab.com/emacs-stuff/git-commit-insert-issue/tree/master
  - GitHub / GitLab issue integration
** Java
- find a nice syntax checker
** Better IDE-style things?
- maybe [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][CEDET]] or irony?
** Windows 10
Someday, I'm going to be stuck with Windows, be that in the workplace
or otherwise (I'm sure of it). When that day comes, I plan on trying
to set up something like this:
https://www.reddit.com/r/emacs/comments/7a63r4/emacs_in_win10linuxdockerxserver_combo/
** Flower
Task tracking in Emacs. Links with Github and Jira(?): [[https://github.com/PositiveTechnologies/flower/tree/0d7822931e389a8739367fa9d6b0ec785d47ef87][flower]].
** Org-Kanban
A more Emacs-exclusive Kanban board type thing‚Ä¶
https://github.com/gizmomogwai/org-kanban
Not sure how useful this is for collaboration
** EXWM
